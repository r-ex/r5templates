// structs for asset "head" sections
// note: most of these are specifically for the season 3 version of the game

typedef uint64 RPakGuid<format=hex>;
typedef RPakGuid RPakGuidRef<fgcolor=cYellow>;

/*struct Vector3
{
    float x,y,z;
};*/

#include "MiscStructs.bt"

struct PakHdr_t
{
	char id[4] <fgcolor=cLtGreen>;
	uint16 version <fgcolor=cLtBlue>;

    // these are technically the same var but meh
	char flags <fgcolor=cPurple>;
	char IsCompressed <fgcolor=cGreen>;

	FILETIME TimeCreated <name="File Creation Time">;
    uint64 yes <format=hex>;

    if(FILE_VERSION >= 7)
	    uint64 cmpSize;

    if(FILE_VERSION == 8)
	    uint64 EmbeddedStarpakOffset;

    if(FILE_VERSION >= 7)
	    uint64 Padding;

	uint64 dcmpSize;

    if(FILE_VERSION == 6)
	    uint64 Padding;

    if(FILE_VERSION == 8)
	    uint64 EmbeddedStarpakSize;
	uint64 Padding2;

    if(FILE_VERSION == 6)
	    uint32 lenStarpakPaths;
    else
        uint16 lenStarpakPaths;

    if(FILE_VERSION == 8)
	    uint16 lenOptStarpakPaths;

    if(FILE_VERSION == 6)
    {
	    uint32 VirtualSegmentCount;
        uint32 PageCount;
    }
    else
    {
        uint16 VirtualSegmentCount;			// * 0x10
	    uint16 PageCount;		// * 0xC
    }

     if(FILE_VERSION >= 7)
        uint16 PatchIndex;

    if(FILE_VERSION == 8)
        uint16 align;
    

	uint32 DescriptorCount;
	uint32 AssetEntryCount;
	uint32 GuidDescriptorCount;
	uint32 FileRelationCount;

    uint32 ExternalAssetCount;
    uint32 ExternalAssetSize;

    if(FILE_VERSION == 6)
        uint32 what;

    if(FILE_VERSION == 8)
    {
	    char Unk[0x8];
        uint32 UnkCount3;
        char Unk1[0x8];
    }
};

struct RpakPatchHeader
{
	uint32 dataSize;				// Total size of the patch edit stream data (Following all data blocks)
	uint32 patchPageIdx;			// Index into RpakVirtualSegmentBlock[], this entire virtual block is read FIRST, before first asset
};

struct RpakPatchCompressPair
{
	uint64 cmpSize;
	uint64 dcmpSize;
};

struct RpakVirtualSegment
{
	uint32 flags;
	uint32 align;
	uint64 size;
};

struct RpakPageInfo
{
	uint32 segIdx;
	uint32 align;					// Unknown right now
	uint32 dataSize;				// Total size of the block
};

struct RpakDescriptor
{
	uint32 Index;
	uint32 Offset;
};

struct RpakSegmentBlock
{
	uint64 Offset;
	uint64 Size;
};

struct RpakAssetEntry
{
	uint64 NameHash <format=hex, fgcolor=cLtGreen>;
	uint64 Padding;

	int SubHeaderPageIndex;
	int SubHeaderPageOffset;
	int RawDataPageIndex;
	int RawDataPageOffset;

	int64 StarpakOffset;	

    if(FILE_VERSION == 8)			
	    int64 OptionalStarpakOffset;		

	uint16 HighestPageNum; // pageEnd
	uint16 Un2;

	uint32 RelationsStartIndex;		

	uint32 UsesStartIndex; // page index for the list of the assets that this asset uses
	uint32 RelationsCount;  // number of relations
	uint32 UsesCount;      // number of assets that are used/referenced by guid

	uint32 SubHeaderSize;
	uint32 Version;
	char Magic[4] <fgcolor=cWhite>;
};

struct RPakPtr
{
    uint32_t Index;
    uint32_t Offset;
};

struct RpakDescPointer
{
    uint32 Index  <fgcolor=cRed>;
    uint32 Offset <fgcolor=cLtBlue>;
};

enum SegmentFlags
{
    CPU = (1 << 0), // 0x1
    
    SERVER_ONLY = (1 << 5), // 0x20
    CLIENT_ONLY = (1 << 6), // 0x40
    DEV_ONLY = (1 << 7), // 0x80
};

string ReadSegmentFlags(uint flags)
{
    string value = "";

    if(flags == 0)
        return "HEAD";

    int i = 0;
    int flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    if((flags & 1) != 1)
        value += "HEAD | ";

    int flagCounter = 0;
    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case 0x1:
            value += "CPU";
            break;
        case 0x2:
            value += "TEMP";
            break;
        case 0x20:
            value += "SERVER";
            break;
        case 0x40:
            value += "CLIENT";
            break;
        case 0x80:
            value += "DEV";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

////////////
// Assets //
////////////

//
// MATERIALS 
//

enum <byte> MaterialShaderType_t
{
  RGDU = 0x0,
  RGDP = 0x1,
  RGDC = 0x2,
  SKNU = 0x3,
  SKNP = 0x4,
  SKNC = 0x5,
  WLDU = 0x6,
  WLDC = 0x7,
  PTCU = 0x8,
  PTCS = 0x9,
};

struct UnknownMaterialSectionV15
{
    // Spoon - I have kept the names that Rika made for the most part here, except for adding m_ 
    
    // required but seems to follow a pattern. maybe related to "Unknown2" above?
    // nulling these bytes makes the material stop drawing entirely
    uint32_t m_Unknown1[8];
    
    // for more details see the 'UnknownMaterialSectionV12' struct.
    uint32_t m_UnkRenderFlags;
    uint16_t m_VisibilityFlags; // different render settings, such as opacity and transparency.
    uint16_t m_FaceDrawingFlags; // how the face is drawn, culling, wireframe, etc.
    
    uint64_t m_Padding;
};

struct UnknownMaterialSectionV12
{
	// not sure how these work but 0xF0 -> 0x00 toggles them off and vice versa.
	// they seem to affect various rendering filters, said filters might actually be the used shaders.
	// the duplicate one is likely for streamed textures.
	uint32_t unkrenderlighting;
	uint32_t unkrenderaliasing;
	uint32_t unkrenderDoF;
	uint32_t unkrenderunknown;

	uint32_t unkflags; // this changes sometimes.
	uint16_t visibilityflags; // different render settings, such as opacity and transparency.
	uint16_t faceflags; // how the face is drawn, culling, wireframe, etc.

	uint64_t reserved;
};

struct MaterialHeaderV12
{
	uint64_t reservedVtbl; // Gets set to CMaterialGlue vtbl ptr
	uint8_t padding[8]; // unused

	uint64_t guid; // guid of this material asset

	RPakPtr szdebugName <read=ReadString(pageoffsets[this.Index] + this.Offset)>; // pointer to partial asset path
	RPakPtr szsurfaceProp <read=ReadString(pageoffsets[this.Index] + this.Offset)>; // pointer to surfaceprop (as defined in surfaceproperties.txt)
	RPakPtr szsurfaceProp2; // pointer to surfaceprop2 

	// IDX 1: DepthShadow
	// IDX 2: DepthPrepass
	// IDX 3: DepthVSM
	// IDX 4: ColPass

	uint64_t guidRefs[4]; // Required to have proper textures.

	// these blocks relate to different render filters and flags. still not well understood.
	UnknownMaterialSectionV12 unksections[2];

	uint64_t shadersetGuid; // guid of the shaderset asset that this material uses

	RPakPtr texturesHandles; // TextureGUID Map

	// both should be reserved - used to store the handles for any textures that have streaming mip levels and the number of textures that have streamed mips
	RPakPtr streamingTextureHandles;
	uint16_t streamingTextureCount; // Number of textures with streamed mip levels.

	uint32_t flags; // see ImageFlags in the apex struct.
	uint16_t unknown2; // name carried over from apex struct.

	uint64_t reserved; // nothing is ever placed here (as I've seen so far), probably reserved for stuff on load.

	// seems to be 0xFBA63181 for loadscreens
	uint32_t unknown3; // name carried over from apex struct.

	uint32_t unknown4; // name carried over from apex struct.

	uint32_t flags2;
	uint32_t something2; // seems mostly unchanged between all materials, including apex, however there are some edge cases where this is 0x0.

	uint16_t width;
	uint16_t height;
	uint32_t unknown1; // might be padding but could also be something else such as "m_Unknown1"?.
};

struct MaterialHeaderV15
{
	uint64_t reservedVtbl; // Gets set to CMaterialGlue vtbl ptr
	uint8_t padding[8]; // unused

	uint64_t guid <format=hex>; // guid of this material asset

	RPakPtr szdebugName <read=ReadString(pageoffsets[this.Index] + this.Offset)>; // pointer to partial asset path
	RPakPtr szsurfaceProp <read=ReadString(pageoffsets[this.Index] + this.Offset)>; // pointer to surfaceprop (as defined in surfaceproperties.txt)
	RPakPtr szsurfaceProp2; // pointer to surfaceprop2 

	// IDX 1: DepthShadow
	// IDX 2: DepthPrepass
	// IDX 3: DepthVSM
	// IDX 4: DepthShadowTight
	// IDX 5: ColPass

	uint64_t guidRefs[5]; // Required to have proper textures.
	uint64_t shadersetGuid; // guid of the shaderset asset that this material uses

	RPakPtr texturesHandles; // TextureGUID Map

	// both should be reserved - used to store the handles for any textures that have streaming mip levels and the number of textures that have streamed mips
	RPakPtr streamingTextureHandles;
	uint16_t streamingTextureCount; // Number of textures with streamed mip levels.

	int16 m_nWidth;
	int16 m_nHeight;
	int16 m_Unknown1;
	
	uint32_t m_Flags;
	uint32_t m_Unknown2;
	
	uint32_t m_Unknown3; // REQUIRED but why?
	
	uint32_t m_Unknown4;
	
	// of these 2 seem to be required
	uint32_t m_Flags2;
	uint32_t something2;
	
	UnknownMaterialSectionV15 m_UnknownSections[2];

	uint8_t bytef0;
	uint8_t bytef1;
	MaterialShaderType_t bytef2; // used '4' and '8' observed
	uint8_t bytef3; // used for unksections loading in UpdateMaterialAsset

	uint32_t unk;

    uint64 txanGuid;
};

// header size unchanged all the way until v20, does not mean vars have not changed within
struct MaterialHeaderV16
{
	uint64_t m_VtblReserved; // Gets set to CMaterialGlue vtbl ptr
	uint8_t m_Padding[0x8]; // Un-used.
	uint64_t m_nGUID; // guid of this material asset

	RPakPtr m_pszName; // pointer to partial asset path
	RPakPtr m_pszSurfaceProp; // pointer to surfaceprop (as defined in surfaceproperties.rson)
	RPakPtr m_pszSurfaceProp2; // pointer to surfaceprop2 

	// IDX 1: DepthShadow
	// IDX 2: DepthPrepass
	// IDX 3: DepthVSM
	// IDX 4: DepthShadowTight
	// IDX 5: ColPass

	uint64_t m_GUIDRefs[5]; // Required to have proper textures.
	uint64_t m_pShaderSet; // guid of the shaderset asset that this material uses

	RPakPtr m_pTextureHandle; // TextureGUID Map
	RPakPtr m_pStreamingTextureHandles; // Streamable TextureGUID Map
	
	int16 m_nStreamingTextureHandleCount; // Number of textures with streamed mip levels.
	int16 m_nWidth;
	int16 m_nHeight;
	int16 m_Unknown1;
	
	uint32_t m_Flags;
	uint32_t m_Unknown2;
	
	uint32_t m_Unknown3; // REQUIRED but why?
	
	uint32_t m_Unknown4;
	
	// of these 2 seem to be required
	uint32_t m_Flags2;
	uint32_t something2;
	
	UnknownMaterialSectionV15 m_UnknownSections;

    uint32 unk_v16[2];

    uint8_t bytef0;
	uint8_t bytef1;
	MaterialShaderType_t bytef2; // used '4' and '8' observed
	uint8_t bytef3; // used for unksections loading in UpdateMaterialAsset

	uint32_t unk;

    uint64 txanGuid;

    uint32 unk1_v16[6];
};

struct MaterialHeaderV20
{
	uint64_t unk_v20; // not 
	uint8_t m_Padding[0x8]; // Un-used.
	uint64_t m_nGUID; // guid of this material asset

	RPakPtr m_pszName; // pointer to partial asset path
	RPakPtr m_pszSurfaceProp; // pointer to surfaceprop (as defined in surfaceproperties.rson)
	RPakPtr m_pszSurfaceProp2; // pointer to surfaceprop2 

	// IDX 1: DepthShadow
	// IDX 2: DepthPrepass
	// IDX 3: DepthVSM
	// IDX 4: DepthShadowTight
	// IDX 5: ColPass

	uint64_t m_GUIDRefs[5]; // Required to have proper textures.
	uint64_t m_pShaderSet; // guid of the shaderset asset that this material uses

	RPakPtr m_pTextureHandle; // TextureGUID Map
	RPakPtr m_pStreamingTextureHandles; // Streamable TextureGUID Map
	
	int16 m_nStreamingTextureHandleCount; // Number of textures with streamed mip levels.
	int16 m_nWidth;
	int16 m_nHeight;
	int16 m_Unknown1;
	
	uint32_t m_Flags;
	uint32_t m_Unknown2;
	
	uint32_t m_Unknown3; // REQUIRED but why?
	
	uint32_t m_Unknown4;
	
	// of these 2 seem to be required
	uint32_t m_Flags2;
	uint32_t something2;
	
	UnknownMaterialSectionV15 m_UnknownSections;

    float unkfloat_v20[2];

    uint8_t bytef0;
	uint8_t bytef1;
	MaterialShaderType_t bytef2; // used '4' and '8' observed
	uint8_t bytef3; // used for unksections loading in UpdateMaterialAsset

	uint32_t unk; // seen this as '1' and '3'

    uint64 txanGuid;

    uint32 unk1_v16[5];

    float unkfloat1_v20;
};

struct MaterialCPUHeader
{
	RPakPtr  data; // points to the rest of the cpu data. maybe for colour?
	uint32_t size;
	uint32_t version; // every unknown is now either datasize, version, or flags
};

struct uvTransformMatrix
{
	// this section is actually broken up into three parts.

	// c_uvRotScaleX
	float uvScaleX;
	float uvRotationX; // rotation, but w e i r d.

	// c_uvRotScaleY
	float uvRotationY; //counter clockwise, 0-1, exceeding one causes Weird Stuff to happen.
	float uvScaleY;

	// c_uvTranslate
	float uvTranslateX;
	float uvTranslateY;
};

// some of these vary so this is just very generic
struct MatlCPUData_V12
{
	// the assignment of these depends on the shader set, they work similarly to texturetransforms in normal source.
	uvTransformMatrix c_uv1; // this is frequently used for detail textures.
	uvTransformMatrix c_uv2;
	uvTransformMatrix c_uv3;

	Vector2 c_uvDistortionIntensity; // distortion on the { x, y } axis.
	Vector2 c_uvDistortion2Intensity; // see above, but for a second distortion texture.

	float c_fogColorFactor;

	float c_layerBlendRamp; // blend intensity (assumed), likely the hardness/softness of the two textures meshing.

	Vector3 c_albedoTint; // color of the albedo texture.
	float c_opacity; // untested.

	float c_useAlphaModulateSpecular;
	float c_alphaEdgeFadeExponent;
	float c_alphaEdgeFadeInner;
	float c_alphaEdgeFadeOuter;

	float c_useAlphaModulateEmissive; // almost always set to 1.
	float c_emissiveEdgeFadeExponent;
	float c_emissiveEdgeFadeInner;
	float c_emissiveEdgeFadeOuter;

	float c_alphaDistanceFadeScale;
	float c_alphaDistanceFadeBias;
	float c_alphaTestReference;

	float c_aspectRatioMulV; // this is equal to width divided by height see: 16/9~, not clear what it actually does.

	Vector3 c_emissiveTint; // color of the emission, this is normally set to { 0.0, 0.0, 0.0 } if you don't have an emission mask.

	float c_shadowBias;

	float c_tsaaDepthAlphaThreshold;
	float c_tsaaMotionAlphaThreshold;
	float c_tsaaMotionAlphaRamp;
	uint32_t c_tsaaResponsiveFlag; // this is 0 or 1 I think.

	float c_dofOpacityLuminanceScale;

	//float c_glitchStrength; // only used  sometimes. on 'Glitch' shadersets, if used 'pad_CBufUberStatic' is only two sections.

	uint32_t pad_CBufUberStatic[3]; // this is reserved space for special values, three sections by default.

	float c_perfGloss;

	Vector3 c_perfSpecColor; // specular color, consistent across most materials.
};

//
// SHADERS
//
struct ShaderHeaderV8
{
	RPakPtr name <read=ReadString(pageoffsets[this.Index] + this.Offset)>;

	int unkcount;
    int unkcount1;

	RPakPtr unkdata;
    RPakPtr unkdata1;
};

struct ShaderSetHeader {
	uint8_t Unknown1[0x18];
	uint16_t Count1;
	uint16_t Count2;
	uint16_t Count3;
	uint8_t Byte1;
	uint8_t Byte2;

	uint8_t Unknown2[0x10];

	uint64_t ShaderHash1;
	uint64_t ShaderHash2;

	uint64_t VertexShaderHash;
	uint64_t PixelShaderHash;
};

struct ShaderSetHeaderV8 {

	uint64_t reservedVtbl;
	
    RPakPtr name <read=ReadString(pageoffsets[this.Index] + this.Offset)>;

	uint8_t Unknown1[0x8];

	uint16_t Count1;

	uint16_t textureInputCount;

	uint16_t Count3;
	uint8_t Byte1;
	uint8_t Byte2;

	uint8_t Unknown2[0x8];
    
    uint64_t unk[4];

    /*uint64_t domainShaderGuid
	uint64_t hullShaderGuid;
	uint64_t computeShaderGuid;
	uint64_t geometryShaderGuid;*/
	uint64_t vextexShaderGuid;
	uint64_t pixelShaderGuid;

};

//
// TEXTURES 
//
struct TextureHeader
{
	uint64_t guid <format=hex>;
	RPakPtr szdebugName <read=ReadString(pageoffsets[this.Index] + this.Offset)>;

	uint16_t width <fgcolor=cPurple>;
	uint16_t height <fgcolor=cYellow>;

    // possible int16
    uint16_t Un;
	//uint8_t Un1;
	//uint8_t Un2;

    uint16_t format;  // Maps to a DXGI format

	uint32_t dataSize;	// This is the total amount of image data across all banks

	uint8_t compressionType; // 8 PS4, 9 Switch

	uint8_t optStreamedMipCount; // r5 only

	uint8_t arraySize;
	uint8_t layerCount;

	uint8_t mipFlags; // 0x1 invert mips, 0x2 exists but unk
	uint8_t permanentMipCount;
	uint8_t streamedMipCount;

    byte unk[13]; // mipmap related, used bytes is always total mip count minus one, not present if no mipmaps (see mip count - 1)

    int64 numPixels; // reserved, set on load.
};

struct TextureHeaderV9
{
	RPakPtr szdebugName <fgcolor=cLtRed>;

	uint16_t format;

	uint16_t width <fgcolor=cPurple>;
	uint16_t height <fgcolor=cYellow>;

	uint16_t Un;

	uint16_t arraySize;

    uint16_t un2; // likely layerCount

	uint32_t dataSize_deprecated;

	uint8_t permanentMipCount;
	uint8_t streamedMipCount;
	uint8_t optStreamedMipCount;

	uint8_t un3; // not related to mips, will be present even where there's one mip
	
    int16 unk[10]; // weird mip bytes for unstreamed

    byte unk1[8]; // weird mip level bytes for streamed stuff
};

struct UIIAFlags
{
	uint8_t HasLowTable : 1;
	uint8_t LowTableBc7 : 1;
	uint8_t HasHighTable : 1;
	uint8_t HighTableBc7 : 1;
	// 0x1 = RpakDecompress
	// 0x2 = RpakDecompressSnowflake
	uint8_t CompressionType : 2;
	uint8_t SizeShift : 2;
};

struct UIIAHeader
{
	uint64_t Zero;
	uint64_t NegativeOne;

	uint16_t AtlasCount;

	UIIAFlags Flags;
	uint8_t Padding;
	uint16_t Unknown;
	uint16_t NegativeOne2;

	uint16_t Width;
	uint16_t Height;

	uint32_t Padding2;

	float FloatTable[0x8];
};

struct RUIImage
{
	uint32_t Zero[0x8];

	uint16_t HighResolutionWidth;
	uint16_t HighResolutionHeight;

	uint16_t LowResolutionWidth;
	uint16_t LowResolutionHeight;

	uint32_t BufferIndex;
	uint32_t BufferOffset;

	uint32_t NameIndex;
    uint32_t NameOffset;
    uint32_t Unk[2];
};

//
// UI IMAGE ATLAS
//
struct UIMGHeader
{
	float WidthRatio;
    float HeightRatio;
	uint16_t Width;
	uint16_t Height;
	uint16_t TextureOffsetsCount;
	uint16_t TextureCount;
	uint32_t TextureOffsetsIndex;
	uint32_t TextureOffsetsOffset;
	uint32_t TextureDimsIndex;
	uint32_t TextureDimsOffset;
	uint32_t Unk20;
	uint32_t Unk24;
	uint32_t TextureHashesIndex;
	uint32_t TextureHashesOffset;
	uint32_t TextureNamesIndex;
	uint32_t TextureNamesOffset;
	RPakGuid TextureGuid;
};

struct UIImageOffset
{
	// these don't seem to matter all that much as long as they are a valid float number
	float f0;
	float f1;
	
	// endX and endY define where the edge of the image is, with 1.f being the full length of the image and 0.5f being half of the image
	float endX;
	float endY;

	// startX and startY define where the top left corner is in proportion to the full image dimensions
	float startX;
	float startY;

	// changing these 2 values causes the image to be distorted on each axis
	float unkX;
	float unkY;
};

struct UIImageUV
{
	// maybe the uv coords for top left?
	// just leave these as 0 and it should be fine
	float uv0x;
	float uv0y;

	// these two seem to be the uv coords for the bottom right corner
	// examples:
	// uv1x = 10;
	// | | | | | | | | | |
	// uv1x = 5;
	// | | | | |
	float uv1x;
	float uv1y;
};


//
// MODELS 
//
/*struct ModelHeader
{
	// IDST data
	// .mdl
	RPakPtr pRMDL;
	uint64_t Padding = 0;

	// model path
	// e.g. mdl/vehicle/goblin_dropship/goblin_dropship.rmdl
	RPakPtr pName;
	uint64_t Padding2 = 0;

	// .phy
	RPakPtr pPhyData;
	uint64_t Padding3 = 0;

	// preload cache data for static props
	RPakPtr pStaticPropVtxCache;

	// pointer to data for the model's arig guid(s?)
	RPakPtr pAnimRigs;

	// this is a guess based on the above ptr's data. i think this is == to the number of guids at where the ptr points to
	uint32_t animRigCount = 0;

	// size of the data kept in starpak
	uint32_t unkDataSize = 0;
	uint32_t alignedStreamingSize = 0; // full size of the starpak entry, aligned to 4096.

	uint64_t Padding6 = 0;

	// number of anim sequences directly associated with this model
	uint32_t animSeqCount = 0;
	RPakPtr pAnimSeqs;

	uint64_t Padding7 = 0;
	uint64_t Padding8 = 0;
	uint64_t Padding9 = 0;
};*/

struct ModelHeaderV8
{
	// IDST data
	RPakPtr pRMDL <comment=".rmdl">;

	// model path
	// e.g. mdl/vehicle/goblin_dropship/goblin_dropship.rmdl
	RPakPtr pName <read=ReadString(pageoffsets[this.Index] + this.Offset)>;

	uint64_t unk;

	// charms do not use this, but goblin_dropship and weapons do
	RPakPtr pPHY <comment=".phy">;

	RPakPtr pModelData <comment=".vtx and .vvd. preload data for static props only">;

	// pointer to data for the model's arig guid(s?)
	RPakPtr pRRIG <comment="pointer to the guids of the anim rigs associated with this model">;

	// this is a guess based on the above ptr's data. i think this is == to the number of guids at where the ptr points to
	uint32_t rrigCount;

	// size of the data kept in starpak
	uint32_t unkDataSize;
	uint32_t alignedStreamingSize; // full size of the starpak entry, aligned to 4096.

	// number of anim sequences directly associated with this model
	uint32_t rseqCount;
	RPakPtr pRSEQ;

    uint64_t unk1;
};

struct ModelHeaderV9
{
	// IDST data
	RPakPtr pRMDL <comment=".rmdl">;

    uint64_t unk;

	// model path
	// e.g. mdl/vehicle/goblin_dropship/goblin_dropship.rmdl
	RPakPtr pName <read=ReadString(pageoffsets[this.Index] + this.Offset)>;

	uint64_t unk1;

	// charms do not use this, but goblin_dropship and weapons do
	RPakPtr pPHY <comment=".phy">;

    uint64_t unk2;

	RPakPtr pModelData <comment=".vtx and .vvd combined. preload data for static props only">;

	// pointer to data for the model's arig guid(s?)
	RPakPtr pRRIG <comment="pointer to the guids of the anim rigs associated with this model">;

	// this is a guess based on the above ptr's data. i think this is == to the number of guids at where the ptr points to
	uint32_t rrigCount;

	// size of the data kept in starpak
	uint32_t unkDataSize;
	uint32_t alignedStreamingSize; // full size of the starpak entry, aligned to 4096.

	

    uint64_t unk3;

    uint64_t unk4;
	uint64_t unk5;

    // number of anim sequences directly associated with this model
	uint32_t rseqCount;
	RPakPtr pRSEQ;

	uint64_t unk6;

};

struct ModelHeader
{
	// IDST data
	RPakPtr SkeletonPtr <comment=".rmdl">;
	uint64_t Padding;

	// model path
	// e.g. mdl/vehicle/goblin_dropship/goblin_dropship.rmdl
	RPakPtr Name;
	uint64_t Padding2;

	// charms do not use this, but goblin_dropship and weapons do
	RPakPtr PhyPtr <comment=".phy">;
	uint64_t Padding3;

	RPakPtr StaticPropStreamPreloadData <comment=".vtx and .vvd combined. preload data for static props only">;

	// pointer to data for the model's arig guid(s?)
	RPakPtr AnimRigRefPtr <comment="pointer to the guids of the anim rigs associated with this model">;

	// this is a guess based on the above ptr's data. i think this is == to the number of guids at where the ptr points to
	uint32_t AnimRigCount;

	// size of the data kept in starpak
	uint32_t permanentDataSize;
	uint32_t streamingDataSize;
	uint64_t Padding6;

	// number of anim sequences directly associated with this model
	uint32_t AnimSequenceCount;
	RPakPtr AnimSequencePtr;

	uint64_t Padding7;
	uint64_t Padding8;
	uint64_t Padding9;
};

struct studiohdr_t
{
	int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
	int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
	int checksum; // This has to be the same in the phy and vtx files to load!
	int sznameindex; // This has been moved from studiohdr2 to the front of the main header.
	char name[64]; // The internal name of the model, padding with null bytes.
	                // Typically "my_model.mdl" will have an internal name of "my_model"
	int length; // Data size of MDL file in bytes.
 
	Vector3 eyeposition;	// ideal eye position

	Vector3 illumposition;	// illumination center
	
	Vector3 hull_min;		// ideal movement hull size
	Vector3 hull_max;			

	Vector3 view_bbmin;		// clipping bounding box
	Vector3 view_bbmax;		
 
	int flags;
  
	int numbones; // bones
	int boneindex;
 
	int numbonecontrollers; // bone controllers
	int bonecontrollerindex;
 
	int numhitboxsets;
	int hitboxsetindex;
 
    // unused now
	int numlocalanim; // animations/poses
	int localanimindex; // animation descriptions
 
	int numlocalseq; // sequences
	int	localseqindex;
 
	int activitylistversion; // initialization flag - have the sequences been indexed?
 
	// mstudiotexture_t
	// short rpak path
	// raw textures
    int materialtypesindex;
	int numtextures; // the material limit exceeds 128, probably 256.
	int textureindex;
 
	// this should always only be one, unless using vmts.
	// raw textures search paths
	int numcdtextures;
	int cdtextureindex;
 
	// replaceable textures tables
	int numskinref;
	int numskinfamilies;
	int skinindex;
 
	int numbodyparts;		
	int bodypartindex;
 
	int numlocalattachments;
	int localattachmentindex;
 
	int numlocalnodes;
	int localnodeindex;
	int localnodenameindex;
 
	int numunknodes;
	int unknodexindex;
 
	int meshindex; // offset to model meshes

	int numflexcontrollers;
	int flexcontrollerindex;
 
	int numflexrules;
	int flexruleindex;
 
	int numikchains;
	int ikchainindex;

	// this is rui meshes
	int numruimeshes;
	int ruimeshindex;
 
	int numlocalposeparameters;
	int localposeparamindex;
 
	int surfacepropindex;
 
	int keyvalueindex;
	int keyvaluesize;
 
	int numlocalikautoplaylocks;
	int localikautoplaylockindex;
 
	float mass;
	int contents;
	
	// unused for packed models
	int numincludemodels;
	int includemodelindex;
	
	uint32 virtualModel;

	int bonetablebynameindex;
	
	// if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte rootLOD;
	
	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte numAllowedRootLODs;

	byte unused;

	float fadedistance;
	
	float gathersize; // what. from r5r struct

    int numunk_v54_early;
    int unkindex_v54_early;

	float flVertAnimFixedPointScale; // to be verified
    int surfacepropLookup; // this index must be cached by the loader, not saved in the file

	// this is in all shipped models, probably part of their asset bakery. it should be 0x2CC.
	int mayaindex; // doesn't actually need to be written pretty sure, only four bytes when not present.

	int numsrcbonetransform;
	int srcbonetransformindex;

	int	illumpositionattachmentindex;
	
	int linearboneindex;

	int m_nBoneFlexDriverCount; // unsure if that's what it is in apex
	int m_nBoneFlexDriverIndex;
	
    int unkindexflex;

	int unk1_v54[6];

	// always "" or "Titan"
    int unkstringindex <read=ReadString(mdlHeader.unkstringindex)>;

	// this is now used for combined files in rpak, vtx, vvd, and vvc are all combined while vphy is separate.
	// the indexes are added to the offset in the rpak mdl_ header.
	// vphy isn't vphy, looks like a heavily modified vphy.
	int vtxindex; // VTX
	int vvdindex; // VVD / IDSV
	int vvcindex; // VVC / IDCV 
	int vphyindex; // VPHY / IVPS

	int vtxsize;
	int vvdsize;
	int vvcsize;
	int vphysize; // still used in models using vg

	// unk2_v54[3] is the chunk after following unkindex2's chunk
	int unk2_v54[3]; // the same four unks in v53 I think, the first index being unused now probably

    int unkindex3; // index to chunk after string block

    // Per Tri Collision AABB size
    Vector3 mins;
    Vector3 maxs; // seem to be the same as hull size

    int unk3_v54[3];

	int unkindex4; // chunk before unkindex3 sometimes

	int unk4_v54[3]; // same as unk3_v54_v121

    //int vgindex; // 0tVG
    //int unksize; // might be offset
    //int unksize1; // might be offset
};


struct UIFontData
{
	RPakPtr Ptr1;
	uint64_t Unk1[5];
	RPakPtr Ptr2;
	RPakPtr Ptr3;
	RPakPtr Ptr4;
	RPakPtr Ptr5;
	RPakPtr Ptr6;
};

// size: 40 (0x28)
struct UIFontHeader
{
	uint16_t FontCount;
	uint16_t Unk2;
	uint16_t Width;
	uint16_t Height;
	uint32_t Unk3;
	uint32_t Unk4;
	RPakPtr FontData;
	RPakPtr Ptr2;
	uint64_t AtlasGUID;
};

struct RSONHeader
{
	int type<format=hex>;
	int nodeCount;
	RPakPtr pNodes;
};

struct RSONNode
{
    RPakPtr pName;
    int type;
    int valueCount;
    RPakPtr pValues;
};


// no

enum <char> RuiArgumentType_t
{
  TYPE_NONE = 0,
  TYPE_STRING = 0x1,
  TYPE_ASSET = 0x2,
  TYPE_BOOL = 0x3,
  TYPE_INT = 0x4,
  TYPE_FLOAT = 0x5,
  TYPE_FLOAT2 = 0x6,
  TYPE_FLOAT3 = 0x7,
  TYPE_COLOR_ALPHA = 0x8,
  TYPE_GAMETIME = 0x9,
  TYPE_WALLTIME = 0xA,
  TYPE_UIHANDLE = 0xB,
  TYPE_IMAGE = 0xC,
  TYPE_FONT_FACE = 0xD,
  TYPE_FONT_HASH = 0xE,
  TYPE_ARRAY = 0xF,
};

struct RUIHeader
{
	RPakPtr name;
	RPakPtr values;
	RPakPtr unk2;
	float elementWidth;
	float elementHeight;
	float elementWidthRatio <comment=Str("1/%f", parentof(this).elementWidth)>;
    float elementHeightRatio <comment=Str("1/%f", parentof(this).elementHeight)>;
	RPakPtr argNames;
	RPakPtr argClusters;
	RPakPtr args;
	short argCount; // number of slots for arguments. not all are used
	short unk10Count; // number of "headers" unk10 leads to, if 0 none present.
	uint16_t unk4;
    uint16_t valueSize; // size of values in bytes
	uint16_t unk5;
	uint16_t unk6;
	uint16_t unk7;
	uint16_t argClusterCount;
	RPakPtr unk8;
	RPakPtr unk9;
	RPakPtr unk10; // leads to "headers" for data, the data being vectors
};

struct RuiArgCluster
{
  uint16_t argIndex;
  uint16_t argCount;
  char byte1; // hash_mul
  char byte2; // hash_add
};

struct RuiArg
{
    RuiArgumentType_t type;
    char unk1;
    short valueOffset;
    short nameOffset;
    short short_hash;
};

struct RuiUnk10
{
    uint32_t dataCount; // number of vectors the ptr leads to.
    uint16_t unk1;
    uint16_t unk2;

    RPakPtr data;
};

struct TextureListHeader_t
{
	RPakPtr textureGuids;
	RPakPtr textureNames;
	uint64_t textureCount;
};

struct ShaderHeader
{
  RPakPtr m_pszName;
  char m_byte1;
  char m_byte2;
  char m_byte3;
  char m_byte4;
  char m_byte5;
  char m_byte6;
  char m_byte7;
  char m_byte8;
  RPakPtr m_pUnk1;
  RPakPtr m_pUnk2;
};


struct ParticleScriptHeader
{
    uint64_t m_pTextures[4];
    char unk[0x20];
    RPakPtr m_pszName;
    RPakPtr m_pUnk2;
    uint64_t m_pSysEffectComputeShader; // seems to only be used on particle_script/system.rpak
    uint64_t m_pProcessComputeShader;
    uint64_t m_pRenderVertexShader;
    uint64_t m_pRenderGeometryShader;
    uint64_t m_pRenderPixelShader;
    uint32_t unk2;
    uint32_t unk3;
    uint64_t unk4;
};

struct SettingsLayoutHeader
{
    RPakPtr m_pszName;
    RPakPtr m_pUnk1;
    RPakPtr m_pUnk2;
    uint32_t dwUnk1;
    uint32_t dwUnk2;
    uint32_t dwUnk3;
    uint32_t dwUnk4;
    uint32_t dwUnk5;
    uint32_t dwUnk6;
    uint32_t dwUnk7;
    uint32_t dwUnk8;
    RPakPtr m_pUnk3;
    RPakPtr m_pUnk4;
}; // size = 72

struct SettingsAssetHeader
{
  QWORD layoutGuid<format=hex>;
  RPakPtr pValues;
  RPakPtr pName;
  RPakPtr pStringBuffer;

  uint32_t guid; // actually 31 bit :D
  uint32_t unk1;

  RPakPtr pModNames; // e.g. passives for settings/mp/player/pilot_survival.rpak

  RPakPtr unk2;
  uint32_t valueBufSize;
  char unk[12];
}; // size = 72


// aseq headers
struct ASeqHeaderV7
{
	RPakPtr data; // pointer to raw rseq.
	RPakPtr szname <read=ReadString(pageoffsets[this.Index] + this.Offset)>; // pointer to debug name, placed before raw rseq normally.

	// this can point to a group of guids and not one singular one.
	RPakPtr modelGuid;
	uint32_t modelCount;

    uint32_t reserved;

	// this can point to a group of guids and not one singular one.
	RPakPtr settingsGuid;
	uint32_t settingsCount;

    uint32_t reserved1; // assumed
};

struct ASeqHeaderV71
{
    RPakPtr data; // pointer to raw rseq.
    RPakPtr szname <read=ReadString(pageoffsets[this.Index] + this.Offset)>; // pointer to debug name, placed before raw rseq normally.

	// this can point to a group of guids and not one singular one.
	RPakPtr modelGuid;
	uint32_t modelCount; // to be verified on v7

	// size of data that is not locally in the rseq.
	uint32_t externalDataSize;

	// this can point to a group of guids and not one singular one.
	RPakPtr settingsGuid;
	uint32_t settingsCount;

    uint32_t reserved1; // assumed

	// pointer to data stored outside of the raw rseq.
    RPakPtr externalData;
};

struct ASeqHeaderV10
{
	RPakPtr data; // pointer to raw rseq.
	RPakPtr szname <read=ReadString(pageoffsets[this.Index] + this.Offset)>; // pointer to debug name, placed before raw rseq normally.

    uint64_t Unknown; // possible pointer, guid, or reserved space.

	// counts for mdl_ and stgs assets, normally just one but can be multiples.
    uint16_t modelCount;
    uint16_t settingsCount;

	// size of the external data.
    uint32_t externalDataSize;

	// these can all point to a group of guids and not one singular one.
    RPakPtr modelGuid;
	RPakPtr effectGuid;
    RPakPtr settingsGuid;

	// data that is stored outside of the raw rseq.
    RPakPtr externalData;
};

struct SubtitleHeader
{
    uint32 stringCount;
    uint32 unk2;
    RPakPtr unk3;
    RPakPtr pEntries;
};


struct SubtHashEntry {
    uint hash;
    uint stringoffset;
};

/*struct Vector2
{
    float x,y;
};*/


// 816 bytes...
struct AnimRecordingHeader
{
    // pose param names normally
    RPakPtr keys[15] <read=ReadString(pageoffsets[this.Index] + this.Offset)>;

    // pose param values normally
    Vector2 values[15];
    
    RPakPtr anims[48] <read=ReadString(pageoffsets[this.Index] + this.Offset)>;

    // actions or events?
    RPakPtr unkstring[16] <read=ReadString(pageoffsets[this.Index] + this.Offset)>;

    Vector2 unkvector[3];

    RPakPtr unkdata;
    RPakPtr unkdata1;

    int unkdatacount;
    int unkdatacount1;

    int64 unk;

    byte unk1[4];

    int unk2;
};

struct unkdata_t
{
    float unkfloat[7];

    byte unk[8];

    float unkfloat1[4];

    byte unk1[16];
};

struct unkdata1_t
{
    int unk[2];

    float unkfloat[7];
};

struct MaterialForAspect
{
    RPakGuid rgdu;
    RPakGuid rgdp;
    RPakGuid sknu;
    RPakGuid sknp;
    RPakGuid sknc;
    RPakGuid wldu;
    RPakGuid ptcu;
    RPakGuid ptcs;
};

struct PtchHeader
{
	uint32_t unknown_1; // always FF 00 00 00?
	uint32_t patchedPakCount;

	RPakPtr pPakNames;

	RPakPtr pPakPatchNums;
};

// oh god oh man oh god
struct MapHeader
{
    char unk[104];

    if(AssetEntries[i].Version == 3)
        char unk_v3[16];
};

struct EffectHeader
{
	RPakPtr data;
	int unk2;
	int unk3;
};

struct EffectData
{
	RPakPtr pcfName;
	RPakPtr EffectName; // Double ptr to effect name
	RPakPtr unk2;
	RPakPtr ParticleSystemOperator; // Double ptr to pso name
	RPakPtr unk3;
	RPakPtr unk4;
};