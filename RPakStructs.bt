// structs for asset "head" sections
// note: most of these are specifically for the season 3 version of the game

typedef uint64 RPakGuid<format=hex>;
typedef RPakGuid RPakGuidRef<fgcolor=cYellow>;

/*struct Vector3
{
    float x,y,z;
};*/

#include "MiscStructs.bt"

struct PakHdr_t
{
	char id[4] <fgcolor=cLtGreen>;
	uint16 version <fgcolor=cLtBlue>;

    // these are technically the same var but meh
	char flags <fgcolor=cPurple>;
	char IsCompressed <fgcolor=cGreen>;

	FILETIME TimeCreated <name="File Creation Time">;
    uint64 yes <format=hex>;

	uint64 cmpSize;

    if(FILE_VERSION == 8)
	    uint64 EmbeddedStarpakOffset;

	uint64 Padding;
	uint64 dcmpSize;

    if(FILE_VERSION == 8)
	    uint64 EmbeddedStarpakSize;
	uint64 Padding2;

	uint16 lenStarpakPaths;

    if(FILE_VERSION == 8)
	    uint16 lenOptStarpakPaths;

	uint16 VirtualSegmentCount;			// * 0x10
	uint16 PageCount;		// * 0xC


    uint16 PatchIndex;

    if(FILE_VERSION == 8)
        uint16 align;
    

	uint32 DescriptorCount;
	uint32 AssetEntryCount;
	uint32 GuidDescriptorCount;
	uint32 FileRelationCount;

    uint32 UnkCount;
    uint32 UnkCount2;

    if(FILE_VERSION == 8)
    {
	    char Unk[0x8];
        uint32 UnkCount3;
        char Unk1[0x8];
    }
};

struct RpakPatchHeader
{
	uint32 dataSize;				// Total size of the patch edit stream data (Following all data blocks)
	uint32 patchPageIdx;			// Index into RpakVirtualSegmentBlock[], this entire virtual block is read FIRST, before first asset
};

struct RpakPatchCompressPair
{
	uint64 cmpSize;
	uint64 dcmpSize;
};

struct RpakVirtualSegment
{
	uint32 flags;
	uint32 align;
	uint64 size;
};

struct RpakPageInfo
{
	uint32 segIdx;
	uint32 align;					// Unknown right now
	uint32 dataSize;				// Total size of the block
};

struct RpakDescriptor
{
	uint32 Index;
	uint32 Offset;
};

struct RpakSegmentBlock
{
	uint64 Offset;
	uint64 Size;
};

struct RpakAssetEntry
{
	uint64 NameHash <format=hex, fgcolor=cLtGreen>;
	uint64 Padding;

	uint32 SubHeaderPageIndex;
	uint32 SubHeaderPageOffset;
	uint32 RawDataPageIndex;
	uint32 RawDataPageOffset;

	uint64 StarpakOffset <format=hex>;	

    if(FILE_VERSION == 8)			
	    uint64 OptionalStarpakOffset <format=hex>;		

	uint16 HighestPageNum; // pageEnd
	uint16 Un2;

	uint32 RelationsStartIndex;		

	uint32 UsesStartIndex; // page index for the list of the assets that this asset uses
	uint32 RelationsCount;  // number of relations
	uint32 UsesCount;      // number of assets that are used/referenced by guid

	uint32 SubHeaderSize;
	uint32 Version;
	char Magic[4] <fgcolor=cWhite>;
};

struct RPakPtr
{
    uint32_t Index;
    uint32_t Offset;
};

struct RpakDescPointer
{
    uint32 Index  <fgcolor=cRed>;
    uint32 Offset <fgcolor=cLtBlue>;
};

enum SegmentFlags
{
    CPU = (1 << 0), // 0x1
    
    SERVER_ONLY = (1 << 5), // 0x20
    CLIENT_ONLY = (1 << 6), // 0x40
    DEV_ONLY = (1 << 7), // 0x80
};

string ReadSegmentFlags(uint flags)
{
    string value = "";

    if(flags == 0)
        return "HEAD";

    int i = 0;
    int flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    if((flags & 1) != 1)
        value += "HEAD | ";

    int flagCounter = 0;
    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case 0x1:
            value += "CPU";
            break;
        case 0x2:
            value += "TEMP";
            break;
        case 0x20:
            value += "SERVER";
            break;
        case 0x40:
            value += "CLIENT";
            break;
        case 0x80:
            value += "DEV";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

////////////
// Assets //
////////////

//
// MATERIALS 
//
struct UnknownMaterialSectionV15
{
    // Spoon - I have kept the names that Rika made for the most part here, except for adding m_ 
    
    // required but seems to follow a pattern. maybe related to "Unknown2" above?
    // nulling these bytes makes the material stop drawing entirely
    uint32_t m_Unknown1[8];
    
    // for more details see the 'UnknownMaterialSectionV12' struct.
    uint32_t m_UnkRenderFlags;
    uint16_t m_VisibilityFlags; // different render settings, such as opacity and transparency.
    uint16_t m_FaceDrawingFlags; // how the face is drawn, culling, wireframe, etc.
    
    uint64_t m_Padding;
};

struct UnknownMaterialSectionTF
{
	// nulling these bytes makes the material stop drawing entirely
	uint8_t Unknown5[56];
};

struct MaterialHeaderTF
{
	uint64_t VTablePadding <comment="Reserved bytes used for storing the CMaterialGlue vtable's pointer">;
	uint64_t Padding; // all null bytes
	uint64_t AssetGUID <format=hex>; // for some reason this is the material's guid

	RPakPtr Name; // asset path
	RPakPtr SurfaceName; // surface name (as defined in surfaceproperties.rson)
	uint64_t Padding;


	uint64_t GUIDRefs[4]; // default asset guids
	UnknownMaterialSectionTF UnkSection;
	uint64_t ColpassGUID <format=hex>; // may be blank if this is the colpass asset
	uint64_t ShaderSetGUID <format=hex>;

	RPakPtr TextureGUIDs; // texture guids

	RPakPtr TextureGUIDs2;

    uint8_t Unknown[0x20];
    uint16_t Width;
    uint16_t Height;

    uint32 unk;

};

struct MaterialCPUHeader
{
	RPakPtr  data; // points to the rest of the cpu data. maybe for colour?
	uint32_t size;
	uint32_t version; // every unknown is now either datasize, version, or flags
};

struct MaterialHeaderV15
{
	uint64_t m_VtblReserved; // Gets set to CMaterialGlue vtbl ptr
	uint8_t m_Padding[0x8]; // Un-used.
	uint64_t m_nGUID; // guid of this material asset

	RPakPtr m_pszName; // pointer to partial asset path
	RPakPtr m_pszSurfaceProp; // pointer to surfaceprop (as defined in surfaceproperties.rson)
	RPakPtr m_pszSurfaceProp2; // pointer to surfaceprop2 

	// IDX 1: DepthShadow
	// IDX 2: DepthPrepass
	// IDX 3: DepthVSM
	// IDX 4: DepthShadowTight
	// IDX 5: ColPass

	uint64_t m_GUIDRefs[5]; // Required to have proper textures.
	uint64_t m_pShaderSet; // guid of the shaderset asset that this material uses

	RPakPtr m_pTextureHandle; // TextureGUID Map
	RPakPtr m_pStreamingTextureHandles; // Streamable TextureGUID Map
	
	int16 m_nStreamingTextureHandleCount; // Number of textures with streamed mip levels.
	int16 m_nWidth;
	int16 m_nHeight;
	int16 m_Unknown1;
	
	uint32_t m_Flags;
	uint32_t m_Unknown2;
	
	uint32_t m_Unknown3; // REQUIRED but why?
	
	uint32_t m_Unknown4;
	
	// of these 2 seem to be required
	uint32_t m_Flags2;
	uint32_t something2;
	
	UnknownMaterialSectionV15 m_UnknownSections[2];

	uint8_t bytef0;
	uint8_t bytef1;
	uint8_t bytef2; // used '4' and '8' observed
	uint8_t bytef3; // used for unksections loading in UpdateMaterialAsset

	uint32_t unk;

    uint64 txanhash;
};

// header size unchanged all the way until v20, does not mean vars have not changed within
struct MaterialHeaderV16
{
	uint64_t m_VtblReserved; // Gets set to CMaterialGlue vtbl ptr
	uint8_t m_Padding[0x8]; // Un-used.
	uint64_t m_nGUID; // guid of this material asset

	RPakPtr m_pszName; // pointer to partial asset path
	RPakPtr m_pszSurfaceProp; // pointer to surfaceprop (as defined in surfaceproperties.rson)
	RPakPtr m_pszSurfaceProp2; // pointer to surfaceprop2 

	// IDX 1: DepthShadow
	// IDX 2: DepthPrepass
	// IDX 3: DepthVSM
	// IDX 4: DepthShadowTight
	// IDX 5: ColPass

	uint64_t m_GUIDRefs[5]; // Required to have proper textures.
	uint64_t m_pShaderSet; // guid of the shaderset asset that this material uses

	RPakPtr m_pTextureHandle; // TextureGUID Map
	RPakPtr m_pStreamingTextureHandles; // Streamable TextureGUID Map
	
	int16 m_nStreamingTextureHandleCount; // Number of textures with streamed mip levels.
	int16 m_nWidth;
	int16 m_nHeight;
	int16 m_Unknown1;
	
	uint32_t m_Flags;
	uint32_t m_Unknown2;
	
	uint32_t m_Unknown3; // REQUIRED but why?
	
	uint32_t m_Unknown4;
	
	// of these 2 seem to be required
	uint32_t m_Flags2;
	uint32_t something2;
	
	UnknownMaterialSectionV15 m_UnknownSections;

    uint32 unk_v16[2];

    uint8_t bytef0;
	uint8_t bytef1;
	uint8_t bytef2; // used '4' and '8' observed
	uint8_t bytef3; // used for unksections loading in UpdateMaterialAsset

	uint32_t unk;

    uint64 txanhash;

    uint32 unk1_v16[6];
};

//
// SHADERS
//
struct ShaderSetHeader {
	uint8_t Unknown1[0x18];
	uint16_t Count1;
	uint16_t Count2;
	uint16_t Count3;
	uint8_t Byte1;
	uint8_t Byte2;

	uint8_t Unknown2[0x10];

	uint64_t ShaderHash1;
	uint64_t ShaderHash2;

	uint64_t VertexShaderHash;
	uint64_t PixelShaderHash;
};


//
// TEXTURES 
//
struct TextureHeader
{
	uint64_t NameHash <format=hex>;
	uint32_t NameIndex;
	uint32_t NameOffset;

	uint16_t Width;
	uint16_t Height;

	uint8_t Un1;
	uint8_t Un2;
	uint16_t Format;	// Maps to a DXGI format

	uint32_t DataSize;	// This is the total amount of image data across all banks
	uint8_t Unknown2;
	uint8_t OptMipLevelsStreamed;
	uint8_t LayersCount;
	uint8_t Unknown3;
	uint8_t Unknown4;
	uint8_t MipLevels;
	uint8_t MipLevelsStreamed;

	uint8_t UnknownPad[0x15];
};

struct TextureHeaderV9
{
	RPakPtr debugName<fgcolor=cLtRed>;
	uint16_t format;
	uint16_t width <fgcolor=cPurple>;
	uint16_t height <fgcolor=cYellow>;
	uint16_t un1;
	uint16_t arraySize;
	uint32_t dataSize_deprecated;
	uint8_t permanentMipCount;
	uint8_t streamedMipCount;
	uint8_t optStreamedMipCount;
	uint8_t un2;
	uint8_t un3;
	uint8_t un4;
	uint8_t un5;
	uint8_t UnknownPad[27];
};

struct UIIAFlags
{
	uint8_t HasLowTable : 1;
	uint8_t LowTableBc7 : 1;
	uint8_t HasHighTable : 1;
	uint8_t HighTableBc7 : 1;
	// 0x1 = RpakDecompress
	// 0x2 = RpakDecompressSnowflake
	uint8_t CompressionType : 2;
	uint8_t SizeShift : 2;
};

struct UIIAHeader
{
	uint64_t Zero;
	uint64_t NegativeOne;

	uint16_t AtlasCount;

	UIIAFlags Flags;
	uint8_t Padding;
	uint16_t Unknown;
	uint16_t NegativeOne2;

	uint16_t Width;
	uint16_t Height;

	uint32_t Padding2;

	float FloatTable[0x8];
};

struct RUIImage
{
	uint32_t Zero[0x8];

	uint16_t HighResolutionWidth;
	uint16_t HighResolutionHeight;

	uint16_t LowResolutionWidth;
	uint16_t LowResolutionHeight;

	uint32_t BufferIndex;
	uint32_t BufferOffset;

	uint32_t NameIndex;
    uint32_t NameOffset;
    uint32_t Unk[2];
};

//
// UI IMAGE ATLAS
//
struct UIMGHeader
{
	uint64_t Unk0;
	uint16_t Width;
	uint16_t Height;
	uint16_t TextureOffsetsCount;
	uint16_t TextureCount;
	uint32_t TextureOffsetsIndex;
	uint32_t TextureOffsetsOffset;
	uint32_t TextureDimsIndex;
	uint32_t TextureDimsOffset;
	uint32_t Unk20;
	uint32_t Unk24;
	uint32_t TextureHashesIndex;
	uint32_t TextureHashesOffset;
	uint32_t TextureNamesIndex;
	uint32_t TextureNamesOffset;
	RPakGuid TextureGuid;
};

struct UIImageOffset
{
	// these don't seem to matter all that much as long as they are a valid float number
	float f0;
	float f1;
	
	// endX and endY define where the edge of the image is, with 1.f being the full length of the image and 0.5f being half of the image
	float endX;
	float endY;

	// startX and startY define where the top left corner is in proportion to the full image dimensions
	float startX;
	float startY;

	// changing these 2 values causes the image to be distorted on each axis
	float unkX;
	float unkY;
};

struct UIImageUV
{
	// maybe the uv coords for top left?
	// just leave these as 0 and it should be fine
	float uv0x;
	float uv0y;

	// these two seem to be the uv coords for the bottom right corner
	// examples:
	// uv1x = 10;
	// | | | | | | | | | |
	// uv1x = 5;
	// | | | | |
	float uv1x;
	float uv1y;
};


//
// MODELS 
//
struct ModelHeader
{
	// IDST data
	RPakPtr SkeletonPtr <comment=".rmdl">;
	uint64_t Padding;

	// model path
	// e.g. mdl/vehicle/goblin_dropship/goblin_dropship.rmdl
	RPakPtr Name;
	uint64_t Padding2;

	// charms do not use this, but goblin_dropship and weapons do
	RPakPtr PhyPtr <comment=".phy">;
	uint64_t Padding3;

	RPakPtr StaticPropStreamPreloadData <comment=".vtx and .vvd combined. preload data for static props only">;

	// pointer to data for the model's arig guid(s?)
	RPakPtr AnimRigRefPtr <comment="pointer to the guids of the anim rigs associated with this model">;

	// this is a guess based on the above ptr's data. i think this is == to the number of guids at where the ptr points to
	uint32_t AnimRigCount;

	// size of the data kept in starpak
	uint32_t permanentDataSize;
	uint32_t streamingDataSize;
	uint64_t Padding6;

	// number of anim sequences directly associated with this model
	uint32_t AnimSequenceCount;
	RPakPtr AnimSequencePtr;

	uint64_t Padding7;
	uint64_t Padding8;
	uint64_t Padding9;
};

struct UIFontData
{
	RPakPtr Ptr1;
	uint64_t Unk1[5];
	RPakPtr Ptr2;
	RPakPtr Ptr3;
	RPakPtr Ptr4;
	RPakPtr Ptr5;
	RPakPtr Ptr6;
};

// size: 40 (0x28)
struct UIFontHeader
{
	uint16_t FontCount;
	uint16_t Unk2;
	uint16_t Width;
	uint16_t Height;
	uint32_t Unk3;
	uint32_t Unk4;
	RPakPtr FontData;
	RPakPtr Ptr2;
	uint64_t AtlasGUID;
};

struct RSONHeader
{
	int type<format=hex>;
	int nodeCount;
	RPakPtr pNodes;
};

struct RSONNode
{
    RPakPtr pName;
    int type;
    int valueCount;
    RPakPtr pValues;
};


// no

enum <char> RuiArgumentType_t
{
  TYPE_NONE = 0,
  TYPE_STRING = 0x1,
  TYPE_ASSET = 0x2,
  TYPE_BOOL = 0x3,
  TYPE_INT = 0x4,
  TYPE_FLOAT = 0x5,
  TYPE_FLOAT2 = 0x6,
  TYPE_FLOAT3 = 0x7,
  TYPE_COLOR_ALPHA = 0x8,
  TYPE_GAMETIME = 0x9,
  TYPE_WALLTIME = 0xA,
  TYPE_UIHANDLE = 0xB,
  TYPE_IMAGE = 0xC,
  TYPE_FONT_FACE = 0xD,
  TYPE_FONT_HASH = 0xE,
  TYPE_ARRAY = 0xF,
};


struct RUIHeader
{
	RPakPtr Name;
	RPakPtr Unk1;
	RPakPtr Unk2;
    float elementWidth;
    float elementHeight;
    float UnkFloat3 <comment=Str("1/%f", parentof(this).elementWidth)>;
    float UnkFloat4 <comment=Str("1/%f", parentof(this).elementHeight)>;
    RPakPtr pArgNames;
	RPakPtr pArgClusters;
	RPakPtr pArgs;
	short argCount;
    short unk3;
    uint32_t Unk4;
	uint16_t Unk5;
    uint16_t Unk6;
    uint16_t Unk7;
    uint16_t argClusterCount;
    RPakPtr Unk8;
    RPakPtr Unk9;
    RPakPtr Unk10;
};

struct RuiArgCluster
{
  uint16_t argIndex;
  uint16_t argCount;
  char byte1; // hash_mul
  char byte2; // hash_add
};

struct RuiArg
{
    RuiArgumentType_t type;
    char unk1;
    short valueOffset;
    short nameOffset;
    short short_hash;
};


struct TextureListHeader_t
{
	RPakPtr textureGuids;
	RPakPtr textureNames;
	uint64_t textureCount;
};

struct ShaderHeader
{
  RPakPtr m_pszName;
  char m_byte1;
  char m_byte2;
  char m_byte3;
  char m_byte4;
  char m_byte5;
  char m_byte6;
  char m_byte7;
  char m_byte8;
  RPakPtr m_pUnk1;
  RPakPtr m_pUnk2;
};


struct ParticleScriptHeader
{
    uint64_t m_pTextures[4];
    char unk[0x20];
    RPakPtr m_pszName;
    RPakPtr m_pUnk2;
    uint64_t m_pSysEffectComputeShader; // seems to only be used on particle_script/system.rpak
    uint64_t m_pProcessComputeShader;
    uint64_t m_pRenderVertexShader;
    uint64_t m_pRenderGeometryShader;
    uint64_t m_pRenderPixelShader;
    uint32_t unk2;
    uint32_t unk3;
    uint64_t unk4;
};

struct SettingsLayoutHeader
{
    RPakPtr m_pszName;
    RPakPtr m_pUnk1;
    RPakPtr m_pUnk2;
    uint32_t dwUnk1;
    uint32_t dwUnk2;
    uint32_t dwUnk3;
    uint32_t dwUnk4;
    uint32_t dwUnk5;
    uint32_t dwUnk6;
    uint32_t dwUnk7;
    uint32_t dwUnk8;
    RPakPtr m_pUnk3;
    RPakPtr m_pUnk4;
}; // size = 72

struct SettingsAssetHeader
{
  QWORD layoutGuid<format=hex>;
  RPakPtr pValues;
  RPakPtr pName;
  RPakPtr pStringBuffer;

  uint32_t guid; // actually 31 bit :D
  uint32_t unk1;

  RPakPtr pModNames; // e.g. passives for settings/mp/player/pilot_survival.rpak

  RPakPtr unk2;
  uint32_t valueBufSize;
  char unk[12];
}; // size = 72

struct AnimHeader
{
	RPakPtr data;
	RPakPtr name;
    RPakPtr modelhash;

    uint32 modelcount; // to be verified on v7

    uint32 reserved; // haha surely because this is used later?

    RPakPtr stgshash;

    uint32 stgscount; // to be verified on v7

    uint32 reserved1; // hehe assuming like above :DDD
};

struct AnimHeaderV71
{
	RPakPtr data;
	RPakPtr name;
	RPakPtr modelhash; // hehe haha I love unverified assumptions

    uint32 modelcount; // to be verified on v7

    uint32 externaldatasize;

    RPakPtr stgshash;

    uint32 stgscount; // to be verified on v7

    uint32 reserved1; // hehe assuming like above :DDD

    RPakPtr externaldata;
};

struct AnimHeaderV10
{
	RPakPtr data;
	RPakPtr name;

	uint64 Unknown;

    uint16 modelcount;
    uint16 stgscount;

    uint32 externaldatasize;

	RPakPtr modelhash;
    RPakPtr efcthashes;
    RPakPtr stgshash;

    RPakPtr externaldata;
};

struct SubtitleHeader
{
    uint32 stringCount;
    uint32 unk2;
    RPakPtr unk3;
    RPakPtr pEntries;
};

struct SubtHashEntry {
    uint hash;
    uint stringoffset;
};

struct Vector2
{
    float x,y;
};


// 816 bytes...
struct AnimRecordingHeader
{
    RPakPtr keys[15] <read=ReadString(pageoffsets[this.Index] + this.Offset)>;
    Vector2 values[15];
};

struct MaterialForAspect
{
    RPakGuid rgdu;
    RPakGuid rgdp;
    RPakGuid sknu;
    RPakGuid sknp;
    RPakGuid sknc;
    RPakGuid wldu;
    RPakGuid ptcu;
    RPakGuid ptcs;
};

struct PtchHeader
{
	uint32_t unknown_1; // always FF 00 00 00?
	uint32_t patchedPakCount;

	RPakPtr pPakNames;

	RPakPtr pPakPatchNums;
};

struct mstudioseqdesc_t
{
	int baseptr;

	int	szlabelindex <read=ReadString(startof(parentof(this)) + this)>;

	int szactivitynameindex <read=ReadString(startof(parentof(this)) + this)>;

	int flags; // looping/non-looping flags

	int activity; // initialized at loadtime to game DLL values
	int actweight;

	int numevents;
	int eventindex;
	
	Vector3 bbmin; // per sequence bounding box
	Vector3 bbmax;		

	int numblends;

	// Index into array of shorts which is groupsize[0] x groupsize[1] in length
	int animindexindex;

	int movementindex; // [blend] float array for blended movement
	int groupsize[2];
	int paramindex[2]; // X, Y, Z, XR, YR, ZR
	float paramstart[2]; // local (0..1) starting value
	float paramend[2]; // local (0..1) ending value
	int paramparent;

	float fadeintime; // ideal cross fate in time (0.2 default)
	float fadeouttime; // ideal cross fade out time (0.2 default)

	int localentrynode; // transition node at entry
	int localexitnode; // transition node at exit
	int nodeflags; // transition rules

	float entryphase; // used to match entry gait
	float exitphase; // used to match exit gait
	
	float lastframe; // frame that should generation EndOfSequence

	int nextseq; // auto advancing sequences
	int pose; // index of delta animation between end and nextseq

	int numikrules;

	int numautolayers;
	int autolayerindex;

	int weightlistindex;

	int posekeyindex;

	int numiklocks;
	int iklockindex;

	// Key values
	int keyvalueindex;
	int keyvaluesize;

	int cycleposeindex; // index of pose parameter to use as cycle index

    int activitymodifierindex;
	int numactivitymodifiers;

	int unk;
    int unk1;

    int unkindex;

    int unk2;
};

struct mstudioanimdescv54_t
{
	int baseptr;
	int sznameindex;

	float fps;

	int flags <read=ReadAnimDescFlags>;

    int numframes;

    // piecewise movement
    int nummovements;
    int movementindex;

    int compressedikerrorindex;
    int animindex; // non-zero when anim data isn't in sections

    int numikrules;
    int ikruleindex; // non-zero when IK data is stored in the mdl

    //int numlocalhierarchy;
    //int localhierarchyindex;

    int sectionindex;
    int sectionframes; // number of frames used in each fast lookup section, zero if not used
};

struct mstudioanimdescv54_t_121
{
	int baseptr;
	int sznameindex;

	float fps;

	int flags <read=ReadAnimDescFlags>;

    int numframes;

    // piecewise movement
    int nummovements;
    int movementindex;

    int compressedikerrorindex;
    int animindex; // non-zero when anim data isn't in sections

    int numikrules;
    int ikruleindex; // non-zero when IK data is stored in the mdl

    //int numlocalhierarchy;
    //int localhierarchyindex;

    int sectionindex;
    int sectionframes; // number of frames used in each fast lookup section, zero if not used

    int unk[5];
};

struct mstudioanimsections_t
{
	int animindex;
};

struct sectionindexes_t
{
    mstudioanimsections_t sectionoffsets[(anim.numframes / anim.sectionframes) + 2] <bgcolor=cLtBlue>;
};

struct mstudio_rle_anim_t
{
	int16 size; // actually size and not next offset since it's always filled

    Vector48 rawpos;

    Quat64 rawrot;
};

string ReadAnimDescFlags(uint flags)
{
    string value = "";

    if(flags == 0)
        return "";

    int i = 0;
    int flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);


        // these may not all be right
        switch(flag)
        {
        case 0:
            break;
        case 0x1:
            value += "LOOPING";
            break;
        case 0x2:
            value += "SNAP";
            break;
        case 0x4:
            value += "DELTA";
            break;
        case 0x8:
            value += "AUTOPLAY";
            break;
        case 0x10:
            value += "POST";
            break;
        case 0x20:
            value += "ALLZEROS";
            break;
        case 0x40:
            value += "FRAMEANIM";
            break;
        case 0x80:
            value += "CYCLEPOSE";
            break;
        case 0x100:
            value += "REALTIME";
            break;
        case 0x200:
            value += "LOCAL";
            break;
        case 0x400:
            value += "HIDDEN";
            break;
        case 0x800:
            value += "OVERRIDE";
            break;
        case 0x1000:
            value += "ACTIVITY";
            break;
        case 0x2000:
            value += "EVENT";
            break;
        case 0x4000:
            value += "WORLD";
            break;
        case 0x8000:
            value += "NOFORCELOOP";
            break;
        case 0x10000:
            value += "EVENT_CLIENT";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}

struct posekey_t
{
    float unk[animseq.groupsize[0] + animseq.groupsize[1]];
};

enum eventtype
{
    NEW_EVENT_STYLE = ( 1 << 10 ),
};

struct mstudioevent_t
{
	float cycle;
	int	event;
	eventtype type; // this will be 0 if old style I'd imagine
	char options[256]; // this is the only difference compared to normal v54

	int szeventindex <read=ReadString(startof(parentof(this)) + this)>;
};

struct mstudioevent_t_121
{
	float cycle;
	int	event;
	eventtype type; // this will be 0 if old style I'd imagine
	char options[256]; // this is the only difference compared to normal v54

    int unk;

	int szeventindex <read=ReadString(startof(parentof(this)) + this)>;
};

// autolayer flags
//							0x0001
//							0x0002
//							0x0004
//							0x0008
#define STUDIO_AL_POST		0x0010		// 
//							0x0020
#define STUDIO_AL_SPLINE	0x0040		// convert layer ramp in/out curve is a spline instead of linear
#define STUDIO_AL_XFADE		0x0080		// pre-bias the ramp curve to compense for a non-1 weight, assuming a second layer is also going to accumulate
//							0x0100
#define STUDIO_AL_NOBLEND	0x0200		// animation always blends at 1.0 (ignores weight)
//							0x0400
//							0x0800
#define STUDIO_AL_LOCAL		0x1000		// layer is a local context sequence
//							0x2000
#define STUDIO_AL_POSE		0x4000		// layer blends using a pose parameter instead of parent cycle
#define STUDIO_AL_UNK_53	0x8000		// added in v53 (probably)
                                        // I love this game I love this game I love this game I love this game I love this game I love this game

string ReadAutoLayerFlags(int flags)
{
    string value = "";

    if(flags == 0)
        return "NONE";

    int i = 0;
    int flag = 0;

    int flagsFound = 0;

    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        if(flag != 0)
        {
            flagsFound++;
        }
    }

    int flagCounter = 0;
    for(i = 0; i < 32; i++)
    {
        flag = flags & (1 << i);

        switch(flag)
        {
        case 0:
            break;
        case 0x10:
            value += "STUDIO_AL_POST";
            break;
        case 0x40:
            value += "STUDIO_AL_SPLINE";
            break;
        case 0x80:
            value += "STUDIO_AL_XFADE";
            break;
        case 0x200:
            value += "STUDIO_AL_NOBLEND";
            break;
        case 0x1000:
            value += "STUDIO_AL_LOCAL";
            break;
        case 0x4000:
            value += "STUDIO_AL_POSE";
            break;
        case 0x8000:
            value += "STUDIO_AL_UNK_53";
            break;
        default:
            value += Str("UNK_%x", flag);
            break;
        }

        if(flag != 0)
        {
            flagCounter++;
            if(flagCounter < flagsFound)
            {
                value += " | ";
            }
        }
    }

    return value;
}


struct mstudioautolayer_t
{
    int64 guid; // until you can prove me otherwise this is a guid

	short iSequence;
	short iPose;

	int flags <read=ReadAutoLayerFlags(this)>;
	float start;	// beginning of influence
	float peak;	// start of full influence
	float tail;	// end of full influence
	float end;	// end of all influence
};

struct mstudioactivitymodifier_t_v53
{	
	int sznameindex <read=ReadString(startof(this) + this)>;

    int unk; // 0 or 1 observed.
};

// ik rule
enum ikruletype
{
    IK_SELF = 1,
    IK_WORLD = 2,
    IK_GROUND = 3,
    IK_RELEASE = 4,
    IK_ATTACHMENT = 5,
    IK_UNLATCH = 6
};

struct mstudioikrule_t
{
    int index;
    ikruletype type;
    int chain;
    int bone;

    int slot; // iktarget slot. Usually same as chain.
    float height;
    float radius;
    float floor;
    Vector3 pos;
    Quaternion q;

    float scale[6]; // these values are the same as what posscale (if it was used) and rotscale are.
	int16 offset[6];

    //int compressedikerrorindex;

    int iStart;
    //int ikerrorindex;

    float start; // beginning of influence
    float peak; // start of full influence
    float tail; // end of full influence
    float end; // end of all influence

    float contact; // frame footstep makes ground concact
    float drop; // how far down the foot should drop when reaching for IK
    float top; // top of the foot box

    int szattachmentindex; // name of world attachment

    int unk;

    //int unused[9];
};