//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: RPak
//   Authors: rexx
//   Version: 8
//   Purpose: Respawn Pak files
//  Category: Archive
// File Mask: *.rpak
//  ID Bytes: 52 50 61 6b 08
//   History: 
//------------------------------------------------
typedef unsigned char uint8_t;
typedef uint16 uint16_t;
typedef uint32 uint32_t;
typedef uint64 uint64_t;

local const uint32 FILE_VERSION = ReadInt(4);

#include "RPakStructs.bt"

PakHdr_t pakhdr <fgcolor=0x5268F7>;

local uint64 patchSizeToSkip = 0;
local uint64 pageStart = 0;

if(pakhdr.PatchIndex)
{
    RpakPatchHeader TempPatchHeader <fgcolor=cLtBlue>;
    RpakPatchCompressPair PatchCompressPairs[pakhdr.PatchIndex] <fgcolor=cLtGreen>;
    uint16 PatchIndicesToFile[pakhdr.PatchIndex] <bgcolor=cDkYellow>;

    patchSizeToSkip = TempPatchHeader.PatchDataSize;
    pageStart = TempPatchHeader.PatchSegmentIndex;

    Printf("WARNING: Patch rpaks are not currently supported\n");
}

if(exists(pakhdr.lenStarpakPaths) && pakhdr.lenStarpakPaths > 0)
    char starpakstr[pakhdr.lenStarpakPaths] <bgcolor=cDkGreen>;

if(exists(pakhdr.lenOptStarpakPaths) && pakhdr.lenOptStarpakPaths > 0)
    char starpakoptstr[pakhdr.StarpakOptReferenceSize] <bgcolor=cDkBlue>;

RpakVirtualSegment VirtualSegments[pakhdr.VirtualSegmentCount] <bgcolor=cLtYellow>;
RpakPageInfo Pages[pakhdr.PageCount] <bgcolor=cLtGreen, read=Str("sz %08x | vseg (f: 0x%02x align: 0x%02x) | 0x%02x", this.dataSize, VirtualSegments[this.segIdx].flags, VirtualSegments[this.segIdx].align, this.align), comment=ReadSegmentFlags(VirtualSegments[this.segIdx].flags)>;
RpakDescriptor Descriptors[pakhdr.DescriptorCount] <bgcolor=cLtGray, read=Str("{page: %i ofs: %i}", this.Index, this.Offset)>;
RpakApexAssetEntry AssetEntries[pakhdr.AssetEntryCount] <bgcolor=cBlack, read=Str("%s - %LX", this.Magic, this.NameHash), comment=Str("v%i sz: %i | head: {%i, %i}, cpu: {%i, %i}, unk2: %i", this.Version, this.SubHeaderSize, this.SubHeaderPageIndex, this.SubHeaderPageOffset, this.RawDataPageIndex, this.RawDataPageOffset, this.Un2)>;

RpakDescriptor GuidDescriptors[pakhdr.GuidDescriptorCount];
uint32 FileRelations[pakhdr.FileRelationCount] <hidden=true>;

if(exists(pakhdr.UnkCount3) && pakhdr.UnkCount3 > 0)
    char unk_nonpaged[pakhdr.UnkCount3];

local uint64 pageoffsets[pakhdr.PageCount];

// GoToPageOffset
void GTPO(uint64 Index, uint64 Offset)
{
    FSeek(pageoffsets[Index] + Offset);
}

void GTPTR(RPakPtr& ptr)
{
    FSeek(pageoffsets[ptr.Index] + ptr.Offset);
}

char PatchData[patchSizeToSkip];

local uint64 i = 0;
for(i = pageStart; i < pakhdr.PageCount; ++i)
{
    pageoffsets[i] = FTell();

    struct
    {
        local int idx = i;
        char data[Pages[i].dataSize];
    } data <read=ReadSegmentFlags(VirtualSegments[Pages[this.idx].segIdx].flags)>;

}

// points to every instance of a "page idx, page offset" pointer within page data
for(i = 0; i < pakhdr.DescriptorCount; ++i)
{
    FSeek(pageoffsets[Descriptors[i].Index] + Descriptors[i].Offset);

    RpakDescPointer desc <hidden=true>;
}

// points to every instance of an asset guid reference
for(i = 0; i < pakhdr.GuidDescriptorCount; ++i)
{
    FSeek(pageoffsets[GuidDescriptors[i].Index] + GuidDescriptors[i].Offset);

    RpakGuidReference guid <hidden=true>;
}

string ReadTextureName(TextureHeader& th)
{
    if(th.NameIndex > 0 || th.NameOffset > 0)
        return ReadString(pageoffsets[th.NameIndex] + th.NameOffset);
    else
        return Str("0x%LX", th.NameHash);
};

local uint32 j = 0;
for(i = 0; i < pakhdr.AssetEntryCount; ++i)
{
    if( AssetEntries[i].Magic == "efct" )
    {
        FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        
        char efct;
    }

    if( AssetEntries[i].Magic == "txtr" )
    {
        FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        
        if(AssetEntries[i].Version >= 9)
        {
            TextureHeaderV9 th;
        }
        else
        {
            TextureHeader th <bgcolor=cLtRed, read=ReadTextureName>;
        }
    }

    if( AssetEntries[i].Magic == "rson" )
    {
        
        GTPO(AssetEntries[i].SubHeaderPageIndex, AssetEntries[i].SubHeaderPageOffset);
        RSONHeader rson;

        Printf("\nRSON TYPE: 0x%X\n", rson.type);

        GTPTR(rson.pNodes);

        if(rson.type == 0x1002)
        {
            for(j = 0; j < rson.nodeCount; ++j)
            {
                RPakPtr stringPtr<hidden=true>;
                Printf("%s\n", ReadString(pageoffsets[stringPtr.Index] + stringPtr.Offset));
            };
        } else if(rson.type == 0x1008)
        {
            for(j = 0; j < rson.nodeCount; ++j)
            {
                GTPO(rson.pNodes.Index, rson.pNodes.Offset + (j*8));

                RPakPtr dataPtr<hidden=true>;
                if(dataPtr.Index == 0 && dataPtr.Offset == 0)
                    continue;

                GTPTR(dataPtr);
                RSONNode rsonNode<hidden=false>;

                if(rsonNode.type == 2)
                    Printf("%i, %s: %s\n", j, ReadString(pageoffsets[rsonNode.pName.Index] + rsonNode.pName.Offset), ReadString(pageoffsets[rsonNode.pValues.Index] + rsonNode.pValues.Offset));
                else if (rsonNode.type == 8)
                {
                    
                    for(k = 0; k < rsonNode.valueCount; ++k)
                    {
                        GTPO(rsonNode.pValues.Index, rsonNode.pValues.Offset + (k*8));
                        RSONNode node_what<read=ReadRSONNode>;

                        GTPO(node_what.pName.Index, node_what.pName.Offset);
                        char bruh;

                    }
                } else if(rsonNode.type == 4098)
                {
                    for(k = 0; k < rsonNode.valueCount; ++k)
                    {
                        GTPO(rsonNode.pValues.Index, rsonNode.pValues.Offset + (k*8));
                        RPakPtr ptr_what<hidden=true>;
                        GTPTR(ptr_what);
                    }

                }
                
            };
        }
    }

    if( AssetEntries[i].Magic == "uimg" && false)
    {
        struct UIHashEntry
        {
            uint32 hash;
            uint32 pathoffset;
        };


        GTPO(AssetEntries[i].SubHeaderPageIndex, AssetEntries[i].SubHeaderPageOffset);
        UIMGHeader uh<hidden=false>;

        GTPO(uh.TextureOffsetsIndex, uh.TextureOffsetsOffset);

        UIImageOffset offsets[uh.TextureOffsetsCount];

        GTPO(uh.TextureHashesIndex, uh.TextureHashesOffset);

        struct {
            UIHashEntry h[uh.TextureOffsetsCount];
        } hashes;

        //UIHashEntry hashes[uh.TextureOffsetsCount];

        GTPO(AssetEntries[i].RawDataPageIndex, AssetEntries[i].RawDataPageOffset);

        UIImageUV uvs[uh.TextureOffsetsCount];
    }

    if( AssetEntries[i].Magic == "uiia")
    {
        GTPO(AssetEntries[i].SubHeaderPageIndex, AssetEntries[i].SubHeaderPageOffset);
        UIIAHeader uh<hidden=false>;

        GTPO(AssetEntries[i].RawDataPageIndex, AssetEntries[i].RawDataPageOffset);
        RUIImage ruiimage <read=ReadString(pageoffsets[this.NameIndex] + this.NameOffset)>;
    }

    if( AssetEntries[i].Magic == "matl" && FILE_VERSION == 8 )
    {
        FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        MaterialHeader mh <read=ReadString(pageoffsets[this.Name.Index] + this.Name.Offset), hidden=false>;
        //Printf("%s\n", );
        //Printf("unk: %i, uses: %i\n", AssetEntries[i].Un2, AssetEntries[i].UsesCount);
        //FSeek(pageoffsets[AssetEntries[i].RawDataPageIndex] + AssetEntries[i].RawDataPageOffset);
        //char rdp;
    }

    if( AssetEntries[i].Magic == "shds" )
    {
        //FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        //ShaderSetHeader ssh;
    }

    if( AssetEntries[i].Magic == "shdr" )
    {
        //FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        //ShaderHeader shdr;
    }

    if( AssetEntries[i].Magic == "mdl_" )
    {
        FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        ModelHeader mdlhdr <read=ReadString(pageoffsets[this.Name.Index] + this.Name.Offset)>;
    }

    if( AssetEntries[i].Magic == "ui\0\0" )
    {
        FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        RUIHeader g <read=ReadString(pageoffsets[this.Name.Index] + this.Name.Offset), comment=Str("ac: %i, args: %i", this.argClusterCount, this.argCount), hidden=false>;

        GTPTR(g.pArgClusters);
        RuiArgCluster t;

        GTPTR(g.pArgs);

        if(g.argCount > 0)
        {
            struct {
                RuiArg arg[g.argCount]<read=Str("%X", this.short_hash & 0xFFFF)>;
            } args;
        }
    }

    if( AssetEntries[i].Magic == "txls" )
    {
        FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        //TextureListHeader_t tlh;
    }

    if( AssetEntries[i].Magic == "shdr" )
    {
        // if(AssetEntries[i].RawDataPageIndex != -1)
        //     FSeek(pageoffsets[AssetEntries[i].RawDataPageIndex] + AssetEntries[i].RawDataPageOffset);
    }

    if( AssetEntries[i].Magic == "rpsk" )
    {
        //GTPO(AssetEntries[i].SubHeaderPageIndex, AssetEntries[i].SubHeaderPageOffset);
        //ParticleScriptHeader rpsk<read=Str("particle_script/%s.rpak", ReadString(pageoffsets[this.m_pszName.Index] + this.m_pszName.Offset))>;
        //GTPO(rpsk.m_pUnk2.Index, rpsk.m_pUnk2.Offset);
        //char rpsk2;
    }

    if( AssetEntries[i].Magic == "stlt" )
    {
        GTPO(AssetEntries[i].SubHeaderPageIndex, AssetEntries[i].SubHeaderPageOffset);
        SettingsLayoutHeader stlt<read=ReadString(pageoffsets[this.m_pszName.Index] + this.m_pszName.Offset)>;

        GTPTR(stlt.m_pUnk3);
        char stlt1;
    }

    if( AssetEntries[i].Magic == "subt" )
    {
        GTPO(AssetEntries[i].SubHeaderPageIndex, AssetEntries[i].SubHeaderPageOffset);
        SubtitleHeader subt;

        GTPTR(subt.unk3);
        char fr;
    }

    if( AssetEntries[i].Magic == "stgs" )
    {
        GTPO(AssetEntries[i].SubHeaderPageIndex, AssetEntries[i].SubHeaderPageOffset);
        SettingsAssetHeader stgs<read=ReadString(pageoffsets[this.pName.Index] + this.pName.Offset)>;
    }


    if( AssetEntries[i].Magic == "anir" && false )
    {
        GTPO(AssetEntries[i].SubHeaderPageIndex, AssetEntries[i].SubHeaderPageOffset);
        AnimRecordingHeader anir;

        GTPTR(anir.keys[0]);
        char fr;
    }

    
    if( AssetEntries[i].Magic == "aseq" )
    {
        FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        //AnimHeader anhdr <read=ReadAnimHeader>;
        //GTPTR(anhdr.data);
        //char data;
    }
}