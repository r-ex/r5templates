//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: RPak
//   Authors: rexx
//   Version: 8
//   Purpose: Respawn Pak files
//  Category: Archive
// File Mask: *.rpak
//  ID Bytes: 52 50 61 6b 08
//   History: 
//------------------------------------------------
typedef unsigned char uint8_t;
typedef uint16 uint16_t;
typedef uint32 uint32_t;
typedef uint64 uint64_t;

local const uint32 FILE_VERSION = ReadShort(4);

#include "RPakStructs.bt"


PakHdr_t pakhdr <fgcolor=0x5268F7>;

Assert(pakhdr.dcmpSize == FileSize(), "Invalid dcmpSize. Is your pak compressed?");

local uint64 patchSizeToSkip = 0;
local uint64 pageStart = 0;

if(pakhdr.PatchIndex)
{
    RpakPatchHeader TempPatchHeader <fgcolor=cLtBlue>;
    RpakPatchCompressPair PatchCompressPairs[pakhdr.PatchIndex] <fgcolor=cLtGreen>;
    uint16 PatchIndicesToFile[pakhdr.PatchIndex] <bgcolor=cDkYellow>;

    patchSizeToSkip = TempPatchHeader.PatchDataSize;
    pageStart = TempPatchHeader.PatchSegmentIndex;

    Printf("WARNING: Patch rpaks are not currently supported\n");
}

if(exists(pakhdr.lenStarpakPaths) && pakhdr.lenStarpakPaths > 0)
    char starpakstr[pakhdr.lenStarpakPaths] <bgcolor=cDkGreen>;

if(exists(pakhdr.lenOptStarpakPaths) && pakhdr.lenOptStarpakPaths > 0)
    char starpakoptstr[pakhdr.lenOptStarpakPaths] <bgcolor=cDkBlue>;

RpakVirtualSegment VirtualSegments[pakhdr.VirtualSegmentCount] <bgcolor=cLtYellow>;
RpakPageInfo Pages[pakhdr.PageCount] <bgcolor=cLtGreen, read=Str("sz %08x | vseg (f: 0x%02x align: 0x%02x) | 0x%02x", this.dataSize, VirtualSegments[this.segIdx].flags, VirtualSegments[this.segIdx].align, this.align), comment=ReadSegmentFlags(VirtualSegments[this.segIdx].flags)>;
RpakDescriptor Descriptors[pakhdr.DescriptorCount] <bgcolor=cLtGray, read=Str("{page: %i ofs: %i}", this.Index, this.Offset)>;
RpakAssetEntry AssetEntries[pakhdr.AssetEntryCount] <bgcolor=cBlack, read=Str("%s - %LX", this.Magic, this.NameHash), comment=Str("v%i sz: %i | head: {%i, %i}, cpu: {%i, %i}, unk2: %i", this.Version, this.SubHeaderSize, this.SubHeaderPageIndex, this.SubHeaderPageOffset, this.RawDataPageIndex, this.RawDataPageOffset, this.Un2)>;

RpakDescriptor GuidDescriptors[pakhdr.GuidDescriptorCount];
uint32 FileRelations[pakhdr.FileRelationCount] <hidden=true>;

if(exists(pakhdr.UnkCount3) && pakhdr.UnkCount3 > 0)
    char unk_nonpaged[pakhdr.UnkCount3];

local uint64 pageoffsets[pakhdr.PageCount];

// GoToPageOffset
void GTPO(uint64 Index, uint64 Offset)
{
    FSeek(pageoffsets[Index] + Offset);
}

void GTPTR(RPakPtr& ptr)
{
    FSeek(pageoffsets[ptr.Index] + ptr.Offset);
}

char PatchData[patchSizeToSkip];

local uint64 i = 0;
local int k = 1;
for(i = pageStart; i < pakhdr.PageCount; ++i)
{
    pageoffsets[i] = FTell();

    struct
    {
        local int idx = i;
        char data[Pages[i].dataSize];
    } data <read=ReadSegmentFlags(VirtualSegments[Pages[this.idx].segIdx].flags)>;

}

// points to every instance of a "page idx, page offset" pointer within page data
for(i = 0; i < pakhdr.DescriptorCount; ++i)
{
    FSeek(pageoffsets[Descriptors[i].Index] + Descriptors[i].Offset);

    RpakDescPointer desc <hidden=true>;
}

// points to every instance of an asset guid reference
for(i = 0; i < pakhdr.GuidDescriptorCount; ++i)
{
    FSeek(pageoffsets[GuidDescriptors[i].Index] + GuidDescriptors[i].Offset);

    RPakGuidRef guid <hidden=true>;
}

string ReadTextureName(TextureHeader& th)
{
    if(th.NameIndex > 0 || th.NameOffset > 0)
        return ReadString(pageoffsets[th.NameIndex] + th.NameOffset);
    else
        return Str("0x%LX", th.NameHash);
};

local uint64 j = 0;
local int numbones = 0;
for(i = 0; i < pakhdr.AssetEntryCount; ++i)
{
    GTPO(AssetEntries[i].SubHeaderPageIndex, AssetEntries[i].SubHeaderPageOffset);

    if( AssetEntries[i].Magic == "efct" )
    {
        //char efct;
    }
    else if( AssetEntries[i].Magic == "txtr" )
    {
        
        if(AssetEntries[i].Version >= 9)
        {
            TextureHeaderV9 th;
        }
        else
        {
            TextureHeader th <bgcolor=cLtRed, read=ReadTextureName>;
        }
    }
    else if( AssetEntries[i].Magic == "rson" )
    {
        RSONHeader rson;

        Printf("\nRSON TYPE: 0x%X\n", rson.type);

        GTPTR(rson.pNodes);

        if(rson.type == 0x1002)
        {
            for(j = 0; j < rson.nodeCount; ++j)
            {
                RPakPtr stringPtr<hidden=true>;
                Printf("%s\n", ReadString(pageoffsets[stringPtr.Index] + stringPtr.Offset));
            };
        } else if(rson.type == 0x1008)
        {
            for(j = 0; j < rson.nodeCount; ++j)
            {
                GTPO(rson.pNodes.Index, rson.pNodes.Offset + (j*8));

                RPakPtr dataPtr<hidden=true>;
                if(dataPtr.Index == 0 && dataPtr.Offset == 0)
                    continue;

                GTPTR(dataPtr);
                RSONNode rsonNode<hidden=false>;

                if(rsonNode.type == 2)
                    Printf("%i, %s: %s\n", j, ReadString(pageoffsets[rsonNode.pName.Index] + rsonNode.pName.Offset), ReadString(pageoffsets[rsonNode.pValues.Index] + rsonNode.pValues.Offset));
                else if (rsonNode.type == 8)
                {
                    
                    for(k = 0; k < rsonNode.valueCount; ++k)
                    {
                        GTPO(rsonNode.pValues.Index, rsonNode.pValues.Offset + (k*8));
                        RSONNode node_what<read=ReadRSONNode>;

                        GTPO(node_what.pName.Index, node_what.pName.Offset);
                        char bruh;

                    }
                } else if(rsonNode.type == 4098)
                {
                    for(k = 0; k < rsonNode.valueCount; ++k)
                    {
                        GTPO(rsonNode.pValues.Index, rsonNode.pValues.Offset + (k*8));
                        RPakPtr ptr_what<hidden=true>;
                        GTPTR(ptr_what);
                    }

                }
                
            };
        }
    }
    else if( AssetEntries[i].Magic == "uimg")
    {
        struct UIHashEntry
        {
            uint32 hash;
            uint32 pathoffset;
        };

        UIMGHeader uh<hidden=false>;

        //GTPO(uh.TextureOffsetsIndex, uh.TextureOffsetsOffset);

        //UIImageOffset offsets[uh.TextureOffsetsCount];

        //GTPO(uh.TextureHashesIndex, uh.TextureHashesOffset);

        //struct {
        //    UIHashEntry h[uh.TextureOffsetsCount];
        //} hashes;

        //UIHashEntry hashes[uh.TextureOffsetsCount];

        //GTPO(AssetEntries[i].RawDataPageIndex, AssetEntries[i].RawDataPageOffset);

        //UIImageUV uvs[uh.TextureOffsetsCount];
    }
    else if( AssetEntries[i].Magic == "uiia")
    {
        UIIAHeader uh<hidden=false>;

        GTPO(AssetEntries[i].RawDataPageIndex, AssetEntries[i].RawDataPageOffset);
        RUIImage ruiimage <read=ReadString(pageoffsets[this.NameIndex] + this.NameOffset)>;
    }
    else if( AssetEntries[i].Magic == "matl" && AssetEntries[i].Version == 15)
    {
        MaterialHeaderV15 mh <read=ReadString(pageoffsets[this.m_pszName.Index] + this.m_pszName.Offset), hidden=false>;
        
        FSeek(pageoffsets[AssetEntries[i].RawDataPageIndex] + AssetEntries[i].RawDataPageOffset);
        MaterialCPUHeader matlcpuheader;

        FSeek(pageoffsets[matlcpuheader.data.Index] + matlcpuheader.data.Offset);
        char cpudata;
    }
    else if( AssetEntries[i].Magic == "matl" && AssetEntries[i].Version >= 16)
    {
        MaterialHeaderV16 mh <read=ReadString(pageoffsets[this.m_pszName.Index] + this.m_pszName.Offset), hidden=false>;

        FSeek(pageoffsets[AssetEntries[i].RawDataPageIndex] + AssetEntries[i].RawDataPageOffset);
        MaterialCPUHeader matlcpuheader;

        FSeek(pageoffsets[matlcpuheader.data.Index] + matlcpuheader.data.Offset);
        char cpudata;
    }
    else if( AssetEntries[i].Magic == "matl" && AssetEntries[i].Version == 12)
    {
        MaterialHeaderTF mh <read=ReadString(pageoffsets[this.Name.Index] + this.Name.Offset), hidden=false>;

        FSeek(pageoffsets[AssetEntries[i].RawDataPageIndex] + AssetEntries[i].RawDataPageOffset);
        MaterialCPUHeader matlcpuheader;

        FSeek(pageoffsets[matlcpuheader.data.Index] + matlcpuheader.data.Offset);
        char cpudata;
    }
    else if( AssetEntries[i].Magic == "shds" )
    {
        //FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        //ShaderSetHeader ssh;
    }
    else if( AssetEntries[i].Magic == "shdr" )
    {
        //FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        //ShaderHeader shdr;
    }
    else if( AssetEntries[i].Magic == "mdl_" )
    {
        ModelHeader mdlhdr <read=ReadString(pageoffsets[this.Name.Index] + this.Name.Offset)>;
        GTPTR(mdlhdr.data);

        char data;
    }
    else if( AssetEntries[i].Magic == "ui\0\0" )
    {
        RUIHeader g <read=ReadString(pageoffsets[this.Name.Index] + this.Name.Offset), comment=Str("ac: %i, args: %i", this.argClusterCount, this.argCount), hidden=false>;

        GTPTR(g.pArgClusters);
        RuiArgCluster t;

        GTPTR(g.pArgNames);

        if(g.pArgNames.Index > 0 || g.pArgNames.Offset > 0)
            j = FTell();
        char names;

        GTPTR(g.pArgs);

        if(g.argCount > 0)
        {
            struct {
                local uint64 namepos = j;
                RuiArg arg[g.argCount]<read=Str("%s",this.short_hash == 0 ? "" : ReadString(parentof(this).namepos+this.nameOffset)),
                                       comment=Str("%s, h: %X", EnumToString(this.type), this.short_hash & 0xFFFF)>;
            } args;
        }

        GTPTR(g.Unk1);

        char rui_values;
        
    }
    else if( AssetEntries[i].Magic == "txls" )
    {
        //TextureListHeader_t tlh;
    }
    else if( AssetEntries[i].Magic == "shdr" )
    {
        // if(AssetEntries[i].RawDataPageIndex != -1)
        //     FSeek(pageoffsets[AssetEntries[i].RawDataPageIndex] + AssetEntries[i].RawDataPageOffset);
    }
    else if( AssetEntries[i].Magic == "rpsk" )
    {
        //ParticleScriptHeader rpsk<read=Str("particle_script/%s.rpak", ReadString(pageoffsets[this.m_pszName.Index] + this.m_pszName.Offset))>;
        //GTPO(rpsk.m_pUnk2.Index, rpsk.m_pUnk2.Offset);
        //char rpsk2;
    }
    else if( AssetEntries[i].Magic == "Ptch" )
    {
        PtchHeader ptch;
    }
    else if( AssetEntries[i].Magic == "stlt" )
    {
        SettingsLayoutHeader stlt<read=ReadString(pageoffsets[this.m_pszName.Index] + this.m_pszName.Offset)>;

        GTPTR(stlt.m_pUnk3);
        char stlt1;
    }
    else if( AssetEntries[i].Magic == "subt" )
    {
        SubtitleHeader subt;

        GTPTR(subt.unk3);
        char fr;
    }
    else if( AssetEntries[i].Magic == "stgs" )
    {
        SettingsAssetHeader stgs<read=ReadString(pageoffsets[this.pName.Index] + this.pName.Offset)>;
    }
    else if( AssetEntries[i].Magic == "anir" && false )
    {
        AnimRecordingHeader anir;

        GTPTR(anir.keys[0]);
        char fr;
    }*/
    else if( AssetEntries[i].Magic == "aseq" )
    {
        AnimHeaderV10 anhdr <read=ReadString(pageoffsets[this.name.Index] + this.name.Offset)>;
        GTPTR(anhdr.data);

        struct {
            mstudioseqdesc_t animseq <bgcolor=0xf0b27a, read=Str("SD: %s", ReadString(startof(this) + this.szlabelindex))>;
    
            numbones = (animseq.animindexindex - animseq.weightlistindex) / 4;

            if(animseq.posekeyindex > 0)
            {
                FSeek(startof(animseq) + animseq.posekeyindex);
                posekey_t posekey <bgcolor=0x55ee00>;
            }
        
            if(animseq.numevents > 0)
            {
                FSeek(startof(animseq) + animseq.eventindex);
                for(j = 0; j < animseq.numevents; j++)
                {
                    mstudioevent_t seqevent <bgcolor=0x21fe7a, read=ReadString(startof(this) + this.szeventindex)>;
                }
            }
        
            if(animseq.numautolayers > 0)
            {
                FSeek(startof(animseq) + animseq.autolayerindex);
                for(j = 0; j < animseq.numautolayers; j++)
                {
                    mstudioautolayer_t autolayers <bgcolor=0x226600>;
                }
            }
            
            FSeek(startof(animseq) + animseq.weightlistindex);
            //seqweightlist_t weightlist <bgcolor=0xe1f27a>;
            float weightlist[numbones] <bgcolor=0xe1f27a>;

            FSeek(startof(animseq) + animseq.animindexindex);
            struct
            {
                int animindex[animseq.numblends];
            } animoffsets;
    
            

            for(j = 0; j < animseq.numblends; ++j)
            {
                FSeek(startof(animseq) + animoffsets.animindex[j]);
                mstudioanimdescv54_t anim <bgcolor=0xdc7633, read=Str("ANIMDESC: '%s'", ReadString(startof(this) + this.sznameindex))>;
                
                FSeek(startof(anim[j]) + anim[j].ikruleindex);
	            for (k = 0; k < anim[j].numikrules; ++k)
	            {
		            mstudioikrule_t animikrule <bgcolor=cGreen>;
		            //numikrule += 1;
	            };

                if(anim.sectionindex > 0)
                {
                    
                }                            
            }
        } an;
    }
    else if( AssetEntries[i].Magic == "mt4a" )
    {
        MaterialForAspect mt4a;
    } else {
        struct {
            local int idx = i;
            char data[AssetEntries[i].SubHeaderSize];
        } header_data <name=Str("header_%s", AssetEntries[this.idx].Magic), read=Str("size: %i, guid: %016LX", sizeof(this.data), AssetEntries[this.idx].NameHash)>;
    };
}