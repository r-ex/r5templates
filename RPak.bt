//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: RPak
//   Authors: rexx
//   Version: 8
//   Purpose: Respawn Pak files
//  Category: Archive
// File Mask: *.rpak
//  ID Bytes: 52 50 61 6b 08
//   History: 
//------------------------------------------------
typedef unsigned char uint8_t;
typedef uint16 uint16_t;
typedef uint32 uint32_t;
typedef uint64 uint64_t;

local const uint32 FILE_VERSION = ReadShort(4);

#include "RPakStructs.bt"
#include "MDLStructs.bt"


PakHdr_t pakhdr <fgcolor=0x5268F7>;

if(FILE_VERSION >= 7)
    Assert(pakhdr.dcmpSize == FileSize() || pakhdr.EmbeddedStarpakSize != 0, "Invalid dcmpSize. Is your pak compressed?");

local uint64 patchSizeToSkip = 0;
local uint64 pageStart = 0;

if(FILE_VERSION >= 7)
{
    if(pakhdr.PatchIndex)
    {
        RpakPatchHeader TempPatchHeader <fgcolor=cLtBlue>;
        RpakPatchCompressPair PatchCompressPairs[pakhdr.PatchIndex] <fgcolor=cLtGreen>;
        uint16 PatchIndicesToFile[pakhdr.PatchIndex] <bgcolor=cDkYellow>;
    
        patchSizeToSkip = TempPatchHeader.dataSize;
        pageStart = TempPatchHeader.patchPageIdx;
    
        Printf("WARNING: Patch rpaks are not currently supported\n");
    }
}

if(exists(pakhdr.lenStarpakPaths) && pakhdr.lenStarpakPaths > 0)
    char starpakstr[pakhdr.lenStarpakPaths] <bgcolor=cDkGreen>;

if(exists(pakhdr.lenOptStarpakPaths) && pakhdr.lenOptStarpakPaths > 0)
    char starpakoptstr[pakhdr.lenOptStarpakPaths] <bgcolor=cDkBlue>;

RpakVirtualSegment VirtualSegments[pakhdr.VirtualSegmentCount] <bgcolor=cLtYellow>;
RpakPageInfo Pages[pakhdr.PageCount] <bgcolor=cLtGreen, read=Str("sz %08x | vseg (f: 0x%02x align: 0x%02x) | 0x%02x", this.dataSize, VirtualSegments[this.segIdx].flags, VirtualSegments[this.segIdx].align, this.align), comment=ReadSegmentFlags(VirtualSegments[this.segIdx].flags)>;
RpakDescriptor Descriptors[pakhdr.DescriptorCount] <bgcolor=cLtGray, read=Str("{page: %i ofs: %i}", this.Index, this.Offset)>;
RpakAssetEntry AssetEntries[pakhdr.AssetEntryCount] <bgcolor=cBlack, read=Str("%s - %LX", this.Magic, this.NameHash), comment=Str("v%i sz: %i | head: {%i, %i}, cpu: {%i, %i}, unk2: %i", this.Version, this.SubHeaderSize, this.SubHeaderPageIndex, this.SubHeaderPageOffset, this.RawDataPageIndex, this.RawDataPageOffset, this.Un2)>;

local int guidDescriptorStart = FTell();
local int d;
local int guidDescClumpCount;
//RpakDescriptor GuidDescriptors[pakhdr.GuidDescriptorCount];

if(pakhdr.GuidDescriptorCount)
{
    struct
    {
        for(d = 0; d < pakhdr.AssetEntryCount; d++)
        {
            if(AssetEntries[d].UsesCount)
            {
                FSeek(guidDescriptorStart + (AssetEntries[d].UsesStartIndex * sizeof(RpakDescriptor)));                

                guidDescClumpCount++;

                struct
                {
                    local int assetIdx = d;
                    RpakDescriptor GuidDescriptor[AssetEntries[d].UsesCount];
                } AssetGuidDescriptorGroup <read=Str("%s - %LX", AssetEntries[this.assetIdx].Magic, AssetEntries[this.assetIdx].NameHash)>; // really wish I could name the asset type and hash here but haha 010 and loops funny.
            }
        }
    } GuidDescriptors <fgcolor=cLtYellow>;
}

local int fileRelationStart = FTell();

if(pakhdr.FileRelationCount)
{
    struct
    {
        for(d = 0; d < pakhdr.AssetEntryCount; d++)
        {
            if(AssetEntries[d].RelationsCount)
            {
                FSeek(fileRelationStart + (AssetEntries[d].RelationsStartIndex * 4));                

                struct
                {
                    local int assetIdx = d;
                    int relationIdx[AssetEntries[d].RelationsCount] <read=Str("%s - %LX", AssetEntries[this].Magic, AssetEntries[this].NameHash), comment=Str("Asset Entry Index: %i", this)>;
                } FileRelation <read=Str("%s - %LX", AssetEntries[this.assetIdx].Magic, AssetEntries[this.assetIdx].NameHash)>;
            }
        }
    } FileRelations <fgcolor=cPurple>;
}

if(pakhdr.ExternalAssetCount)
{
    int referencedAssetOffset[pakhdr.ExternalAssetCount] <bgcolor=cLtGreen, read=ReadString(startof(referencedAssetOffset[0]) + (pakhdr.ExternalAssetCount*4) + this)>;
    char referencedAssetStrings[pakhdr.ExternalAssetSize] <fgcolor=cLtGreen>;
}

if(exists(pakhdr.UnkCount3) && pakhdr.UnkCount3 > 0)
    char unk_nonpaged[pakhdr.UnkCount3];

local uint64 pageoffsets[pakhdr.PageCount];



// GoToPageOffset
void GTPO(uint64 Index, uint64 Offset)
{
    FSeek(pageoffsets[Index] + Offset);
}

void GTPTR(RPakPtr& ptr)
{
    FSeek(pageoffsets[ptr.Index] + ptr.Offset);
}

char PatchData[patchSizeToSkip];

local uint64 i = 0;
local int k = 1;
for(i = pageStart; i < pakhdr.PageCount; ++i)
{
    pageoffsets[i] = FTell();

    struct
    {
        local int idx = i;
        char data[Pages[i].dataSize];
    } data <read=ReadSegmentFlags(VirtualSegments[Pages[this.idx].segIdx].flags), comment=Str("%i", this.idx)>;

}
// points to every instance of a "page idx, page offset" pointer within page data
for(i = 0; i < pakhdr.DescriptorCount; ++i)
{
    FSeek(pageoffsets[Descriptors[i].Index] + Descriptors[i].Offset);

    RpakDescPointer desc <hidden=true>;
}

local int guidDescCount;

// points to every instance of an asset guid reference
for(i = 0; i < guidDescClumpCount; ++i)
{
    
    guidDescCount = sizeof(GuidDescriptors.AssetGuidDescriptorGroup[i]) / sizeof(RpakDescriptor);

    for(d = 0; d < guidDescCount; d++)
    {
        FSeek(pageoffsets[GuidDescriptors.AssetGuidDescriptorGroup[i].GuidDescriptor[d].Index] + GuidDescriptors.AssetGuidDescriptorGroup[i].GuidDescriptor[d].Offset);

        RPakGuidRef guid <hidden=true>;
    }
}

string ReadTextureName(TextureHeader& th)
{
    if(th.szdebugName.Index > 0 || th.szdebugName.Offset > 0)
        return ReadString(pageoffsets[th.szdebugName.Index] + th.szdebugName.Offset);
    else
        return Str("0x%LX", th.guid);
};

string ReadSubtHashEntry(SubtHashEntry& sh, SubtitleHeader& subt)
{
    if(sh.hash == 0)
        return "";

    return ReadString(pageoffsets[subt.pEntries.Index] + subt.pEntries.Offset + sh.stringoffset);
};
local uint64 j = 0;
local int numbones = 0;
local int numtextures = 0;

for(i = 0; i < pakhdr.AssetEntryCount; ++i)
{
    GTPO(AssetEntries[i].SubHeaderPageIndex, AssetEntries[i].SubHeaderPageOffset);

    if( AssetEntries[i].Magic == "efct" )
    {
        //char efct;
    }
    else if( AssetEntries[i].Magic == "txtr" )
    {
        
        if(AssetEntries[i].Version >= 9)
        {
            TextureHeaderV9 th;
        }
        else
        {
            TextureHeader th <bgcolor=cLtRed, read=ReadTextureName>;
        }
    }
    else if( AssetEntries[i].Magic == "rmap" )
    {
       MapHeader maph;
    }
    /*else if( AssetEntries[i].Magic == "rson" )
    {
        RSONHeader rson;

        Printf("\nRSON TYPE: 0x%X\n", rson.type);

        GTPTR(rson.pNodes);

        if(rson.type == 0x1002)
        {
            for(j = 0; j < rson.nodeCount; ++j)
            {
                RPakPtr stringPtr<hidden=true>;
                Printf("%s\n", ReadString(pageoffsets[stringPtr.Index] + stringPtr.Offset));
            };
        } else if(rson.type == 0x1008)
        {
            for(j = 0; j < rson.nodeCount; ++j)
            {
                GTPO(rson.pNodes.Index, rson.pNodes.Offset + (j*8));

                RPakPtr dataPtr<hidden=true>;
                if(dataPtr.Index == 0 && dataPtr.Offset == 0)
                    continue;

                GTPTR(dataPtr);
                RSONNode rsonNode<hidden=false>;

                if(rsonNode.type == 2)
                    Printf("%i, %s: %s\n", j, ReadString(pageoffsets[rsonNode.pName.Index] + rsonNode.pName.Offset), ReadString(pageoffsets[rsonNode.pValues.Index] + rsonNode.pValues.Offset));
                else if (rsonNode.type == 8)
                {
                    
                    for(k = 0; k < rsonNode.valueCount; ++k)
                    {
                        GTPO(rsonNode.pValues.Index, rsonNode.pValues.Offset + (k*8));
                        RSONNode node_what<read=ReadRSONNode>;

                        GTPO(node_what.pName.Index, node_what.pName.Offset);
                        char bruh;

                    }
                } else if(rsonNode.type == 4098)
                {
                    for(k = 0; k < rsonNode.valueCount; ++k)
                    {
                        GTPO(rsonNode.pValues.Index, rsonNode.pValues.Offset + (k*8));
                        RPakPtr ptr_what<hidden=true>;
                        GTPTR(ptr_what);
                    }

                }
                
            };
        }
    }*/
    /*else if( AssetEntries[i].Magic == "uimg")
    {
        struct UIHashEntry
        {
            uint32 hash;
            uint32 pathoffset;
        };

        UIMGHeader uh<hidden=false>;

        

        if(uh.Unk20)
        {
            FSeek(pageoffsets[uh.Unk20] + uh.Unk24);
            struct
            {
                UIImageOffset unkoffsets[uh.TextureCount];
            } uvunkunkoffsets;
        }

        GTPO(uh.TextureOffsetsIndex, uh.TextureOffsetsOffset);

        struct {
            UIImageOffset offsets[uh.TextureOffsetsCount];
        } uimgoffsets;

        //UIImageOffset offsets[uh.TextureOffsetsCount];

        GTPO(uh.TextureHashesIndex, uh.TextureHashesOffset);

        struct {
            UIHashEntry h[uh.TextureOffsetsCount];
        } hashes;

        //UIHashEntry hashes;

        GTPO(AssetEntries[i].RawDataPageIndex, AssetEntries[i].RawDataPageOffset);

        struct
        {
            UIImageUV uvs[uh.TextureOffsetsCount];
        } uvsgroup;

        //UIImageUVGroup uvsgroup;
    }*/
    else if( AssetEntries[i].Magic == "uiia")
    {
        UIIAHeader uh<hidden=false>;

        GTPO(AssetEntries[i].RawDataPageIndex, AssetEntries[i].RawDataPageOffset);
        RUIImage ruiimage <read=ReadString(pageoffsets[this.NameIndex] + this.NameOffset)>;
    }
    else if( AssetEntries[i].Magic == "matl" && AssetEntries[i].Version >= 16)
    {
        MaterialHeaderV16 mh <read=ReadString(pageoffsets[this.m_pszName.Index] + this.m_pszName.Offset), hidden=false>;

        FSeek(pageoffsets[AssetEntries[i].RawDataPageIndex] + AssetEntries[i].RawDataPageOffset);
        MaterialCPUHeader matlcpuheader;

        FSeek(pageoffsets[matlcpuheader.data.Index] + matlcpuheader.data.Offset);
        char cpudata;
    }
    else if( AssetEntries[i].Magic == "matl" && AssetEntries[i].Version == 15)
    {
        MaterialHeaderV15 mh <read=ReadString(pageoffsets[this.szdebugName.Index] + this.szdebugName.Offset), hidden=false>;

        numtextures = (mh.streamingTextureHandles.Offset - mh.texturesHandles.Offset) / 8;

        FSeek(pageoffsets[mh.texturesHandles.Index] + mh.texturesHandles.Offset);

        struct
        {
            uint64 guid[numtextures];
            uint64 streamedGuid[numtextures];
            
            string surfaceprop <fgcolor=cLtRed>;

            if(mh.szsurfaceProp2.Index || mh.szsurfaceProp2.Offset)
                string surfaceprop2 <fgcolor=cLtRed>;

        } materialdata;

        FSeek(pageoffsets[AssetEntries[i].RawDataPageIndex] + AssetEntries[i].RawDataPageOffset);
        MaterialCPUHeader matlcpuheader;

        FSeek(pageoffsets[matlcpuheader.data.Index] + matlcpuheader.data.Offset);
        char cpudata;
    }
    else if( AssetEntries[i].Magic == "matl" && AssetEntries[i].Version == 12)
    {
        MaterialHeaderV12 mh <read=ReadString(pageoffsets[this.szdebugName.Index] + this.szdebugName.Offset), hidden=false>;

        numtextures = (mh.streamingTextureHandles.Offset - mh.texturesHandles.Offset) / 8;

        FSeek(pageoffsets[mh.texturesHandles.Index] + mh.texturesHandles.Offset);

        struct
        {
            uint64 guid[numtextures];
            uint64 streamedGuid[numtextures];
            
            string surfaceprop <fgcolor=cLtRed>;

            if(mh.szsurfaceProp2.Index || mh.szsurfaceProp2.Offset)
                string surfaceprop2 <fgcolor=cLtRed>;

        } materialdata;

        FSeek(pageoffsets[AssetEntries[i].RawDataPageIndex] + AssetEntries[i].RawDataPageOffset);
        MaterialCPUHeader matlcpuheader;

        FSeek(pageoffsets[matlcpuheader.data.Index] + matlcpuheader.data.Offset);
        MatlCPUData_V12 cpudata;

        

    }
    /*else if( AssetEntries[i].Magic == "shds" )
    {
        FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        ShaderSetHeader ssh;
    }*/
    /*else if( AssetEntries[i].Magic == "shdr" )
    {
        //FSeek(pageoffsets[AssetEntries[i].SubHeaderPageIndex] + AssetEntries[i].SubHeaderPageOffset);
        //ShaderHeader shdr;
    }
    else if( AssetEntries[i].Magic == "mdl_" )
    {
        ModelHeader mdlhdr <read=ReadString(pageoffsets[this.Name.Index] + this.Name.Offset)>;
        GTPTR(mdlhdr.data);

        char data;
    }*/
    /*else if( AssetEntries[i].Magic == "ui\0\0" )
    {
        RUIHeader g <read=ReadString(pageoffsets[this.name.Index] + this.name.Offset), comment=Str("ac: %i, args: %i", this.argClusterCount, this.argCount), hidden=false>;

        GTPTR(g.argClusters);
        RuiArgCluster t;

        GTPTR(g.argNames);

        if(g.argNames.Index > 0 || g.argNames.Offset > 0)
            j = FTell();
        char names;

        GTPTR(g.args);

        if(g.argCount > 0)
        {
            struct {
                local uint64 namepos = j;
                RuiArg arg[g.argCount]<read=Str("%s",this.short_hash == 0 ? "" : ReadString(parentof(this).namepos+this.nameOffset)),
                                       comment=Str("%s, h: %X", EnumToString(this.type), this.short_hash & 0xFFFF)>;
            } args;
        }

        GTPTR(g.values);

        struct
        {
            char values[g.valueSize]; // values for the args
        } rui_values;

        GTPTR(g.unk2);
        char unk2data;

        GTPTR(g.unk8);
        char unk8data;

        GTPTR(g.unk9);
        char unk9data;

        if(g.unk10.Offset)
        {
            GTPTR(g.unk10);

            struct
            {
                RuiUnk10 unk10[g.unk10Count];
            } unk10data;
        }
        
    }*/
    /*else if( AssetEntries[i].Magic == "txls" )
    {
        //TextureListHeader_t tlh;
    }
    else if( AssetEntries[i].Magic == "shdr" )
    {
        // if(AssetEntries[i].RawDataPageIndex != -1)
        //     FSeek(pageoffsets[AssetEntries[i].RawDataPageIndex] + AssetEntries[i].RawDataPageOffset);
    }
    else if( AssetEntries[i].Magic == "rpsk" )
    {
        //ParticleScriptHeader rpsk<read=Str("particle_script/%s.rpak", ReadString(pageoffsets[this.m_pszName.Index] + this.m_pszName.Offset))>;
        //GTPO(rpsk.m_pUnk2.Index, rpsk.m_pUnk2.Offset);
        //char rpsk2;
    }
    else if( AssetEntries[i].Magic == "Ptch" )
    {
        PtchHeader ptch;
    }
    else if( AssetEntries[i].Magic == "stlt" )
    {
        SettingsLayoutHeader stlt<read=ReadString(pageoffsets[this.m_pszName.Index] + this.m_pszName.Offset)>;

        GTPTR(stlt.m_pUnk3);
        char stlt1;
    }
    else if( AssetEntries[i].Magic == "subt" )
    {

        SubtitleHeader subt;

        GTPTR(subt.unk3);

        SubtHashEntry hashentry[subt.unk2]<read=ReadSubtHashEntry(this,subt)>;
    }
    else if( AssetEntries[i].Magic == "stgs" )
    {
        SettingsAssetHeader stgs<read=ReadString(pageoffsets[this.pName.Index] + this.pName.Offset)>;
    }
    else if( AssetEntries[i].Magic == "anir" && false )
    {
        AnimRecordingHeader anir;

        GTPTR(anir.keys[0]);
        char fr;
    }*/
    /*else if( AssetEntries[i].Magic == "aseq" && AssetEntries[i].Version == 10 )
    {
        ASeqHeaderV10 anhdr <read=ReadString(pageoffsets[this.szname.Index] + this.szname.Offset)>;

        GTPTR(anhdr.data);

        struct
        {
            #include "./RSEQ/rseq_v10.bt" // this is just way more compact and I have all the math done     
        } an;
    }
    else if( AssetEntries[i].Magic == "aseq" && AssetEntries[i].Version == 7 && AssetEntries[i].SubHeaderSize == 56)
    {
        ASeqHeaderV71 anhdr <read=ReadString(pageoffsets[this.szname.Index] + this.szname.Offset)>;

        GTPTR(anhdr.data);

        struct
        {
            #include "./RSEQ/rseq_v71.bt" // this is just way more compact and I have all the math done     
        } an;
    }
    else if( AssetEntries[i].Magic == "aseq" && AssetEntries[i].Version == 7 )
    {
        ASeqHeaderV7 anhdr <read=ReadString(pageoffsets[this.szname.Index] + this.szname.Offset)>;

        GTPTR(anhdr.data);

        struct
        {
            #include "./RSEQ/rseq_v7.bt" // this is just way more compact and I have all the math done     
        } an;
    }*/
    /*else if( AssetEntries[i].Magic == "mt4a" )
    {
        MaterialForAspect mt4a;
    } else {
        struct {
            local int idx = i;
            char data[AssetEntries[i].SubHeaderSize];
        } header_data <name=Str("header_%s", AssetEntries[this.idx].Magic), read=Str("size: %i, guid: %016LX", sizeof(this.data), AssetEntries[this.idx].NameHash), comment=Str("version: %i", AssetEntries[this.idx].Version)>;
    };*/
}