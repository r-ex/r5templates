//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: 
//   Authors: 
//   Version: 
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------
#include "MiscStructs.bt"
typedef unsigned char uint8_t;
typedef uint16 uint16_t;
typedef uint32 uint32_t;
typedef uint64 uint64_t;

typedef enum <uint64> {
    VG_POSITION = 0x1,
    VG_PACKED_POSITION = 0x2,
    VG_VERTEX_COLOR = 0x10,

    VG_PACKED_WEIGHTS = 0x5000,
    VG_UV_LAYER = 0x200000000, // what
    
} VGFLAGS;

#define MAX_NUM_BONES_PER_VERT 3

struct VGHeader
{
	char id[4] <fgcolor=cLtGreen>;		// 0x47567430	'0tvg'
	uint32 version;	    // 0x1
	uint32 unk;	        // Usually 0
	uint32 dataSize;	// Total size of data + header in starpak

	uint64 boneRemapOffset; // offset to bone remap buffer
	uint64 boneRemapCount;  // number of "bone remaps" (size: 1)

	uint64 meshOffset;   // offset to mesh buffer
	uint64 meshCount;    // number of meshes (size: 0x48)

	uint64 indexOffset;     // offset to index buffer
	uint64 indexCount;      // number of indices (size: 2 (uint16_t))

	uint64 vertexOffset;    // offset to vertex buffer
	uint64 vertexCount;     // number of bytes in vertex buffer

	uint64 extendedWeightsOffset;   // offset to extended weights buffer
	uint64 extendedWeightsCount;    // number of bytes in extended weights buffer

    
    // there is one for every LOD mesh
    // i.e, unknownCount == lod.meshCount for all LODs
	uint64 unknownOffset;   // offset to buffer
	uint64 unknownCount;    // count (size: 0x30)

	uint64 lodOffset;       // offset to LOD buffer
	uint64 lodCount;        // number of LODs (size: 0x8)

	uint64 externalWeightsOffset;   // offset to external weights buffer
	uint64 externalWeightsCount;     // number of external weights (size: 0x10)

	uint64 stripsOffset;    // offset to strips buffer
	uint64 stripsCount;     // number of strips (size: 0x23)

    char unused[0x40];
};

struct VGMesh
{
	__int64 flags <fgcolor=cLtGreen, read=Str("0x%LX", this)>;	// mesh flags
	int vertexOffset;			// start offset for this mesh's vertices
	int vertCacheSize;		    // number of bytes used from the vertex buffer
	int vertexCount;			// number of vertices
	int unk1;
	int extendedWeightsOffset;	// start offset for this mesh's "extended weights"
	int extendedWeightsSize;    // size or count of extended weights
	int indexOffset;			// start offset for this mesh's "indices"
	int indexCount;				// number of indices
	int externalWeightsOffset;	// seems to be an offset into the "external weights" buffer for this mesh
	int externalWeightsCount;   // seems to be the number of "external weights" that this mesh uses
	int stripsOffset;			// Index into the strips structs
	int stripsCount;
	int Int15;
	int Int16;
	int Int17;
	int Int18;
};

enum <ubyte> StripHeaderFlags_t
{
	STRIP_IS_TRILIST		= 0x01,
	STRIP_IS_QUADLIST_REG	= 0x02,		// Regular sub-d quads
	STRIP_IS_QUADLIST_EXTRA = 0x04		// Extraordinary sub-d quads
};


// A strip is a piece of a stripgroup which is divided by bones 
struct StripHeader_t
{
	int numIndices;
	int indexOffset;

	int numVerts;    
	int vertOffset;

	short numBones;

	StripHeaderFlags_t flags;

	int numBoneStateChanges;
	int boneStateChangeOffset;

	// MDL Version 49 and up only
	int numTopologyIndices;
	int topologyOffset;
};

struct ModelLODHeader_t
{
	uint16 meshIndex;
	uint16 meshCount;
	float distance;
};

struct PackedPosition
{
    DWORD dword[2];
};

string UnpackPosition(PackedPosition& pos)
{
    	//x = ((_Value[0] & 0x1FFFFF) * 0.0009765625) - 1024.0;
		//y = ((((_Value[1] & 0x3FFu) << 11) + (_Value[0] >> 21)) * 0.0009765625) - 1024.0;
		//z = ((_Value[1] >> 10) * 0.0009765625) - 2048.0;
    local float x = ((pos.dword[0] & 0x1FFFFF) * 0.0009765625) - 1024.0;
    local float y = ((((pos.dword[1] & 0x3FF) << 11) + (pos.dword[0] >> 21)) * 0.0009765625) - 1024.0;
    local float z = ((pos.dword[1] >> 10) * 0.0009765625) - 2048.0;
    return Str("< %f, %f, %f >", x, y, z);
};

string UnpackNormal(DWORD _Value)
{
		local float x, y, z;

		local float v87 = ((2 * _Value) >> 30);
		local int v88 = 255;
		if (((8 * _Value) >> 31) != 0.0)
			v88 = -255;
		local float v89 = (float)v88;
		local float v90 = ((_Value << 13) >> 23) + -256.0;
		local float v91 = ((16 * _Value) >> 23) + -256.0;
		local float v92 = ((v91 * v91) + (255.0 * 255.0)) + (v90 * v90);

		local float v93 = Sqrt(v92);
		local int v97 = 0;

		local float v1, v2, v3;

		v1 = v90 * (1.0 / v93);
		v2 = v89 * (1.0 / v93);
		v3 = v91 * (1.0 / v93);
		if (v87 == 1.0)
			v97 = -1;
		else
			v97 = 0;
		if (v87 == 2.0)
		{
			x = v3;
			y = v1;
			z = v2;
		}
		else
		{
			x = v2;
			y = v3;
			z = v1;
		}
		if (!v97)
		{
			v1 = x;
			v2 = y;
			v3 = z;
		}
		return Str("< %f, %f, %f >", v1, v2, v3);
};

struct PackedVertexWeights
{
	short BlendWeights[2] <read=Str("%f", this /  32768.5)>; // haha jk.. unless?
    byte BlendIds[4]; // last two flags?
};

struct extendedWeight
{
    byte unk[4];
};

struct mstudioboneweight_t
{
	float	weight[MAX_NUM_BONES_PER_VERT];
	char	bone[MAX_NUM_BONES_PER_VERT]; 
	byte	numbones;
};

struct VertexColor
{
    byte r,g,b,a;
};

VGHeader vhdr;

// asserts
if( vhdr.id != "0tVG" || vhdr.version != 1 )
    Assert(0, "invalid magic/version");
//if( FileSize() != vhdr.dataSize )
//    Assert(0, "invalid data size");

local uint64 i = 0;

FSeek(vhdr.boneRemapOffset);
ubyte BoneRemaps[vhdr.boneRemapCount];

FSeek(vhdr.lodOffset);
ModelLODHeader_t lod[vhdr.lodCount]<bgcolor=cLtGray>;

struct unkdata
{
    int64 unk;
    float unk1;
    char data[0x24];
};

FSeek(vhdr.unknownOffset);
unkdata unk_data[vhdr.unknownCount]<bgcolor=cYellow>;

for(i = 0; i < vhdr.meshCount; ++i)
{
    FSeek(vhdr.meshOffset + (i * sizeof(VGMesh)));

    VGMesh mesh <bgcolor=cLtRed>;

    if(mesh.flags == 0 || mesh.vertexCount == 0)
        continue;

    if(mesh.unk1 != 0)
    {
        Printf("unk1: %i\n", mesh.unk1);
    }

    // Indices

    FSeek(vhdr.indexOffset + (mesh.indexOffset * sizeof(short)));

    struct
    {
        short data[mesh.indexCount];
    } indexData<read=Str("%i indices", sizeof(this.data) / 2), bgcolor=cLtBlue>;

    // Vertices

    FSeek(vhdr.vertexOffset + mesh.vertexOffset);

    struct
    {
        local int vertexCount = mesh.vertexCount;
        struct
        {
            if(mesh.flags & 1)
                Vector3 pos;
            else if(mesh.flags & 2)
                PackedPosition pos <read=UnpackPosition>;

            if((mesh.flags & 0x5000) == 0x5000)
                PackedVertexWeights weights;

            DWORD normal <read=UnpackNormal>; // packed normal

            if(mesh.flags & 0x10)
                VertexColor color;

            if(mesh.flags & 0x200000000)
                Vector2 UVLayer;

            Vector2 m_vecTexCoord;

        } vtx[mesh.vertexCount];
    } vertexData<read=Str("%i bytes, %i verts", sizeof(this.vtx), this.vertexCount), bgcolor=cDkBlue>;


    if(mesh.extendedWeightsSize != 0)
    {
        FSeek(vhdr.extendedWeightsOffset + mesh.extendedWeightsOffset);
    
        struct
        {
            extendedWeight data[mesh.extendedWeightsSize / 4];
        } extendedWeightsData<read=Str("%i bytes", sizeof(this.data)), bgcolor=cDkGreen>;
    }

    if(mesh.externalWeightsCount != 0)
    {
        FSeek(vhdr.externalWeightsOffset + (mesh.externalWeightsOffset * sizeof(mstudioboneweight_t)));
    
        struct
        {
            mstudioboneweight_t m_BoneWeights[mesh.externalWeightsCount];
        } externalWeightsData<read=Str("%i weights", sizeof(this.m_BoneWeights)  / 16), bgcolor=cDkGreen>;
    }
    
    // Strips

    FSeek(vhdr.stripsOffset + (mesh.stripsOffset * sizeof(StripHeader_t)));

    struct
    {
        StripHeader_t data[mesh.stripsCount];
    } stripData<read=Str("%i strips", sizeof(this.data) / sizeof(StripHeader_t)), bgcolor=cLtBlue>;
}
